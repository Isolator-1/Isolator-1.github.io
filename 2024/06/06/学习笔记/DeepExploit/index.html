

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/chtholly1.jpg">
  <link rel="icon" href="/img/chtholly1.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#4c81b9">
  <meta name="author" content="Isolator">
  <meta name="keywords" content="">
  
    <meta name="description" content="自动化渗透测试工具">
<meta property="og:type" content="article">
<meta property="og:title" content="Deep Exploit 程序分析">
<meta property="og:url" content="https://isolator-1.github.io/2024/06/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DeepExploit/index.html">
<meta property="og:site_name" content="Isolator&#39;s Blog">
<meta property="og:description" content="自动化渗透测试工具">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://isolator-1.github.io/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DeepExploit/1.png">
<meta property="og:image" content="https://isolator-1.github.io/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DeepExploit/2.png">
<meta property="og:image" content="https://isolator-1.github.io/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DeepExploit/3.png">
<meta property="og:image" content="https://isolator-1.github.io/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DeepExploit/4.png">
<meta property="og:image" content="https://isolator-1.github.io/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DeepExploit/5.png">
<meta property="og:image" content="https://isolator-1.github.io/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DeepExploit/6.png">
<meta property="og:image" content="https://isolator-1.github.io/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DeepExploit/7.png">
<meta property="article:published_time" content="2024-06-06T07:08:00.000Z">
<meta property="article:modified_time" content="2024-07-23T10:37:12.434Z">
<meta property="article:author" content="Isolator">
<meta property="article:tag" content="渗透测试">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://isolator-1.github.io/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DeepExploit/1.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Deep Exploit 程序分析 - Isolator&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"isolator-1.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>_φ_(．．) Chtholly Nota Seniorious</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/chtholly2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Deep Exploit 程序分析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-06-06 15:08" pubdate>
          June 6, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          3.4k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          29 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Deep Exploit 程序分析</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Deep-Exploit-程序分析"><a href="#Deep-Exploit-程序分析" class="headerlink" title="Deep Exploit 程序分析"></a>Deep Exploit 程序分析</h1><h2 id="一-使用方法"><a href="#一-使用方法" class="headerlink" title="一. 使用方法"></a>一. 使用方法</h2><p>下载仓库代码，安装运行环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/13o-bbr-bbq/machine_learning_security.git<br>pip3 install -r requirements.txt<br></code></pre></td></tr></table></figure>

<p>但实际安装时是手动逐个安装的，比如<code>matplotlib==3.0.3</code>可能因为版本太旧了装不上，只能用新的版本。</p>
<p>按照官方文档，使用时需要两台机器，一台远程服务器运行metasploit，一台主机执行这个仓库的<code>DeepExploit.py</code>，远程服务器通过RPC（远程过程调用）来运行 DeepExploit。但实际使用时把两端都放在一台主机上也是可以的（以下过程都是基于此）。</p>
<p>在<code>config.ini</code>中，可以配置运行metasploit主机的RPC的用户名和密码</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">[Common]<br>server_host : 192.168.71.131<br>server_port : 55553<br>msgrpc_user : <span class="hljs-type">test</span><br>msgrpc_pass : <span class="hljs-type">test1234</span><br></code></pre></td></tr></table></figure>

<p>服务端启动metasploit框架，监听指定端口</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">msfdb init<br>msfconsole<br>load msgrpc <span class="hljs-attribute">ServerHost</span>=192.168.71.131 <span class="hljs-attribute">ServerPort</span>=55553 <span class="hljs-attribute">User</span>=test <span class="hljs-attribute">Pass</span>=test1234<br></code></pre></td></tr></table></figure>

<p>客户端运行DeepExploit建立连接</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">python DeepExploit.py -t <span class="hljs-string">...</span> -m <span class="hljs-string">...</span> -s <span class="hljs-string">...</span> -p <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure>

<p>客户端参数</p>
<p>-t 代表攻击的目标主机</p>
<p>-m 有两种选项，train或test，后面会具体介绍</p>
<p>-p 指定端口</p>
<p>-s 指定要测试的服务或应用程序，可供选择的服务见<a href="#config_ini">config.ini</a>，通常与-p一同使用</p>
<h2 id="二-各文件-代码作用"><a href="#二-各文件-代码作用" class="headerlink" title="二. 各文件/代码作用"></a>二. 各文件/代码作用</h2><div id="config_ini"></div>
### 0. config.ini

<p>包含程序各个部分的参数配置</p>
<p><code>[Common]</code> : 程序要远程连接到运行metasploit的服务器端，common部分包含服务器端的ip、端口、用户名、密码；此外，还包含程序内动态生成的训练数据（<code>train_data</code>）的存储位置</p>
<p><code>[Utility]</code>：util.py用到的一些参数，不重要</p>
<p><code>[State]</code> : 包含 能够识别的目标主机操作系统列表，可供选择的服务/程序列表</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">windows unix solaris osx netware linux irix hpux freebsd firefox <span class="hljs-keyword">dialup </span><span class="hljs-keyword">bsdi </span>apple_ios <span class="hljs-keyword">android </span>aix unknown<br><br>vsftpd ssh telnet postfix <span class="hljs-keyword">bind </span>apache rpc samba <span class="hljs-keyword">java </span>proftpd mysql postgresql vnc irc <span class="hljs-keyword">jetty </span>tomcat ldap nginx php phpmyadmin wordpress <span class="hljs-keyword">joomla </span>drupal sugarcrm webmin moodle dav oscommerce tikiwiki phpbb mediawiki unix python ubuntu http ms-wbt-server upnp<br></code></pre></td></tr></table></figure>

<p><code>[A3C]</code> : 训练时超参数</p>
<p><code>[Nmap]</code> : 调用nmap的命令行指令</p>
<p><code>[Report]</code> : 生成报告的配置信息，比如日期</p>
<p><code>[VersionChecker][VersionCheckerML][ContentExplorer]</code>：这三者是分析目标主机端口运行的程序时用到的配置参数 </p>
<p><code>[Spider]</code> : 爬虫的配置信息，包括爬虫结果的存储路径、爬虫时的timeout和并发请求数量等</p>
<h3 id="1-util-py"><a href="#1-util-py" class="headerlink" title="1. util.py"></a>1. util.py</h3><p>只包含一个类<code>Utility</code>，功能包括：</p>
<p>格式化输出（<code>print_message</code>、<code>print_exception</code>）</p>
<p>网页爬虫（<code>parse_url</code>、<code>run_spider</code>）在<a href="#get_target_info"><code>Metasploit.get_target_info</code></a>中被使用</p>
<p>字符串处理（<code>delete_ctrl_char</code>、<code>transform_date_object</code>、<code>transform_date_string</code>）</p>
<p>发送http请求（<code>send_request</code>）</p>
<p>检查目标端口是否是http或https协议（<code>check_web_port</code>）在<a href="#get_target_info"><code>Metasploit.get_target_info</code></a>中被使用</p>
<h3 id="2-CreateReport-py"><a href="#2-CreateReport-py" class="headerlink" title="2. CreateReport.py"></a>2. CreateReport.py</h3><p>只包含一个类<code>CreateReport</code>，只有一个函数<code>create_report</code>，用于生成报告，不重要</p>
<h3 id="3-Spider-py"><a href="#3-Spider-py" class="headerlink" title="3. Spider.py"></a>3. Spider.py</h3><p>包含了网络爬虫的脚本，这个py文件会在<a href="#get_target_info"><code>Metasploit.get_target_info</code></a>中，通过scrapy 命令进行调用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">command = <span class="hljs-string">&#x27;scrapy runspider&#x27;</span> + close_opton + <span class="hljs-string">&#x27;Spider.py&#x27;</span> + option<br></code></pre></td></tr></table></figure>

<p>代码的功能是从一个指定的起始URL开始，递归地爬取网页，并从中提取链接和脚本资源</p>
<p>详细用法见 <a href="#get_target_info"><code>Metasploit.get_target_info</code></a></p>
<h3 id="4-modules文件夹"><a href="#4-modules文件夹" class="headerlink" title="4.  modules文件夹"></a>4.  modules文件夹</h3><p>其中有<code>ContentExplorer.py</code>，<code>NaiveBayes.py</code>，<code>VersionChecker.py</code>，<code>VersionCheckerML.py</code> 四个程序</p>
<p>会在后面用到的时候一并分析，不单独介绍</p>
<p>均是在<a href="#get_target_info"><code>Metasploit.get_target_info</code></a> 用到的，功能是如何用基于指纹/基于机器学习的方法对目标主机上运行的服务进行识别。</p>
<h3 id="5-DeepExploit-py"><a href="#5-DeepExploit-py" class="headerlink" title="5. DeepExploit.py"></a>5. DeepExploit.py</h3><p>包含程序的核心代码，执行时也是从这个py文件启动</p>
<h4 id="class-Msgrpc"><a href="#class-Msgrpc" class="headerlink" title="class Msgrpc"></a><strong>class Msgrpc</strong></h4><p>这个类定义了许多与metasploit服务器进行<strong>交互的</strong> <strong>基本操作</strong>，包括如何登陆、如何发送指令、如何维持与服务器的会话状态。</p>
<p><strong><code>__init__</code></strong> </p>
<p>从 config.ini 读取用户名和密码，用来和服务器立端的metasploit建连接，metasploit的RPC连接实现其实就是一个http/https协议</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">client = Msgrpc(&#123;<span class="hljs-string">&#x27;host&#x27;</span>: server_host, <span class="hljs-string">&#x27;port&#x27;</span>: server_port&#125;)<br></code></pre></td></tr></table></figure>



 <div id="msgrpc_call"></div> 
**`call`** 

<p>调用metasploit的 RPC API，用来指导服务器端的metasploit执行什么命令，有两个参数，meth、origin_option</p>
<p>Msgrpc这个类中，后面的函数几乎都是在用这个<code>call</code>函数通过不同的命令来与metasploit服务器进行交互，例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ret = self.call(<span class="hljs-string">&#x27;console.create&#x27;</span>, [])<br>self.console_id = ret.get(<span class="hljs-string">b&#x27;id&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>这个例子通过<code>console.create</code>命令创建了一个远程的cmd，call函数会返回cmd的id，后面只需要使用这个id编号就可以在服务器上执行命令了，例如 读取命令行的输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">call(<span class="hljs-string">&#x27;console.read&#x27;</span>, [self.console_id])<br></code></pre></td></tr></table></figure>

<p>或者指定执行的命令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">call(<span class="hljs-string">&#x27;console.write&#x27;</span>, [console_id, command])<br></code></pre></td></tr></table></figure>



<p><strong><code>set_api_option</code></strong></p>
<p>在发送请求到Metasploit 服务器之前，会根据需要调用的API方法（<code>meth</code>）准备相应的选项参数（<code>option</code>）</p>
<p>比如在已经验证过用户名密码之后，每次交互都要把用来验证身份的<code>token</code>加到选项里<a href="#log_in">（详见<code>Msgrpc.log_in</code>）</a></p>
<p><strong><code>send_request</code></strong></p>
<p>这个函数就是<code>call</code>函数发送http报文的具体实现，将抽象的 ”指令“ 转化为具体的 ”http报文“ 发送给metasploit服务器</p>
 <div id="log_in"></div> 
**`log_in`**

<p>通过发送用户名和密码登录metasploit服务器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ret = self.call(<span class="hljs-string">&#x27;auth.login&#x27;</span>, [user, password])<br>self.token = ret.get(<span class="hljs-string">b&#x27;token&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>登陆成功后会拿到一个<code>token</code>，后续交互使用这个<code>token</code>维持身份认证</p>
<p><strong><code>keep_alive</code></strong></p>
<p>保持会话存活，具体做法是发送一个获取版本的指令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.send_command(self.console_id, <span class="hljs-string">&#x27;version\n&#x27;</span>, <span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>



<p><strong><code>get_console</code></strong></p>
<p>向服务器申请一个命令行，详见<a href="#msgrpc_call"><code>Msgrpc.call</code></a></p>
<p><strong><code>send_command</code></strong></p>
<p>对指定的命令行发送命令，并获取返回结果，详见<a href="#msgrpc_call"><code>Msgrpc.call</code></a></p>
<p>可以通过参数中的<code>Visualization</code>参数控制是否输出命令执行结果</p>
<div id="get_module_list“></div>
**`get_module_list`**

<p>获取metasploit的模块，模块可以是漏洞利用（exploits）、辅助（auxiliary）、后期利用（post）、载荷（payloads）、编码器（encoders）或 NOP 滑梯（nops），通过参数<code>module_type</code>指定获取哪一类模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ret = self.call(<span class="hljs-string">&#x27;module.xxxxxxx&#x27;</span>, [])<br></code></pre></td></tr></table></figure>

<blockquote>
<p>在Metasploit框架中，模块是指具有特定功能的插件，它们可以执行各种安全测试任务。每个模块都封装了测试或攻击某个特定目标所需的逻辑和数据。Metasploit框架中的模块类型主要包括：</p>
<ol>
<li><strong>漏洞利用（Exploits）</strong>：这些模块利用目标软件中的安全漏洞来获取对目标系统的访问权限。它们可以执行远程代码执行、权限提升、拒绝服务攻击等。</li>
<li><strong>辅助（Auxiliary）</strong>：辅助模块用于支持性任务，如端口扫描、服务识别、漏洞检测等。它们不直接攻击目标，而是为攻击提供信息。</li>
<li><strong>后期利用（Post）</strong>：后期利用模块在成功利用漏洞后执行，用于进一步操作，如提升权限、收集敏感数据、清理痕迹等。</li>
<li><strong>载荷（Payloads）</strong>：当一个漏洞被成功利用时，载荷是被上传到目标系统上执行的代码。它通常用于在目标机器上建立一个会话，如反向shell。</li>
<li><strong>编码器（Encoders）</strong>：编码器模块用于对载荷进行编码或加密，以规避目标系统的安全机制，如入侵检测系统（IDS）或防病毒软件。</li>
<li><strong>Nops</strong>：NOP滑梯是一系列无操作（NOP）指令的序列，它们可以被用来覆盖缓冲区溢出攻击中的多余空间。</li>
</ol>
</blockquote>
<p>为了方便理解，这个call函数对应的真实msfconsonle指令是show，比如<code>show exploits</code>就会列出所有exploits模块下的漏洞，以下是输出结果中的一部分</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">...</span><br><span class="hljs-number">2322  </span><span class="hljs-string">exploit/windows/tftp/quick_tftp_pro_mode</span>                                            <span class="hljs-number">2008-03-27       </span><span class="hljs-string">good</span>       <span class="hljs-literal">No</span>     <span class="hljs-string">Quick</span> <span class="hljs-string">FTP</span> <span class="hljs-string">Pro</span> <span class="hljs-number">2.1</span> <span class="hljs-string">Transfer-Mode</span> <span class="hljs-string">Overflow</span><br><span class="hljs-number">2323  </span><span class="hljs-string">exploit/windows/tftp/tftpd32_long_filename</span>                                          <span class="hljs-number">2002-11-19       </span><span class="hljs-string">average</span>    <span class="hljs-literal">No</span>     <span class="hljs-string">TFTPD32</span> <span class="hljs-string">Long</span> <span class="hljs-string">Filename</span> <span class="hljs-string">Buffer</span> <span class="hljs-string">Overflow</span><br><span class="hljs-number">2324  </span><span class="hljs-string">exploit/windows/tftp/tftpdwin_long_filename</span>                                         <span class="hljs-number">2006-09-21       </span><span class="hljs-string">great</span>      <span class="hljs-literal">No</span>     <span class="hljs-string">TFTPDWIN</span> <span class="hljs-string">v0.4.2</span> <span class="hljs-string">Long</span> <span class="hljs-string">Filename</span> <span class="hljs-string">Buffer</span> <span class="hljs-string">Overflow</span><br><span class="hljs-number">2325  </span><span class="hljs-string">exploit/windows/tftp/tftpserver_wrq_bof</span>                                             <span class="hljs-number">2008-03-26       </span><span class="hljs-string">normal</span>     <span class="hljs-literal">No</span>     <span class="hljs-string">TFTP</span> <span class="hljs-string">Server</span> <span class="hljs-string">for</span> <span class="hljs-string">Windows</span> <span class="hljs-number">1.4</span> <span class="hljs-string">ST</span> <span class="hljs-string">WRQ</span> <span class="hljs-string">Buffer</span> <span class="hljs-string">Overflow</span><br><span class="hljs-number">2326  </span><span class="hljs-string">exploit/windows/tftp/threectftpsvc_long_mode</span>                                        <span class="hljs-number">2006-11-27       </span><span class="hljs-string">great</span>      <span class="hljs-literal">No</span>     <span class="hljs-string">3CTftpSvc</span> <span class="hljs-string">TFTP</span> <span class="hljs-string">Long</span> <span class="hljs-string">Mode</span> <span class="hljs-string">Buffer</span> <span class="hljs-string">Overflow</span><br><span class="hljs-number">2327  </span><span class="hljs-string">exploit/windows/unicenter/cam_log_security</span>                                          <span class="hljs-number">2005-08-22       </span><span class="hljs-string">great</span>      <span class="hljs-literal">Yes</span>    <span class="hljs-string">CA</span> <span class="hljs-string">CAM</span> <span class="hljs-string">log_security()</span> <span class="hljs-string">Stack</span> <span class="hljs-string">Buffer</span> <span class="hljs-string">Overflow</span> <span class="hljs-string">(Win32)</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure>





<p><strong><code>get_module_info</code></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ret = self.call(<span class="hljs-string">&#x27;module.info&#x27;</span>, [module_type, module_name])<br></code></pre></td></tr></table></figure>

<p>针对<code>get_module_list</code>得到的列表中的某一项，获取其信息，例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">exploit_candidate_list = self.client.get_module_list(<span class="hljs-string">&#x27;exploit&#x27;</span>)<br><span class="hljs-keyword">for</span> idx, exploit <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(exploit_candidate_list):<br>    module_info = self.client.get_module_info(<span class="hljs-string">&#x27;exploit&#x27;</span>, exploit)<br></code></pre></td></tr></table></figure>



<p><strong><code>get_compatible_payload_list</code></strong></p>
<p>发送一个模块的名字，返回这个模块有哪些<code>payloads</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ret = self.call(<span class="hljs-string">&#x27;module.compatible_payloads&#x27;</span>, [module_name])<br>byte_list = ret[<span class="hljs-string">b&#x27;payloads&#x27;</span>]<br></code></pre></td></tr></table></figure>



<p><strong><code>get_target_compatible_payload_list</code></strong></p>
<p>类似上一个函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ret = self.call(<span class="hljs-string">&#x27;module.target_compatible_payloads&#x27;</span>, [module_name, target_num])<br>byte_list = ret[<span class="hljs-string">b&#x27;payloads&#x27;</span>]<br></code></pre></td></tr></table></figure>

<blockquote>
<p>两者的区别：</p>
<ol>
<li><strong>compatible_payloads</strong>：<ul>
<li>此方法返回与特定漏洞利用模块兼容的所有载荷列表。</li>
<li>它不针对特定的目标或目标编号，而是提供该模块普遍兼容的载荷概览。</li>
</ul>
</li>
<li><strong>target_compatible_payloads</strong>：<ul>
<li>此方法返回与特定漏洞利用模块以及特定目标编号（target index）兼容的载荷列表。</li>
<li>它更具体，因为它考虑了模块支持的目标中特定的一个，并返回适合该特定目标的载荷。</li>
</ul>
</li>
</ol>
<p>简而言之，<code>compatible_payloads</code> 提供了一个广泛的兼容载荷列表，而 <code>target_compatible_payloads</code> 则根据指定的目标提供了一个更加定制化的兼容载荷列表。</p>
</blockquote>
<p><strong><code>get_module_options</code></strong></p>
<p>获取指定的模块的选项</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.call(<span class="hljs-string">&#x27;module.options&#x27;</span>, [module_type, module_name])<br></code></pre></td></tr></table></figure>

<p>比如使用exploit模块里的某个漏洞，使用时要指明攻击的目标主机的ip，这个ip就是options里的一项。</p>
<p><strong><code>execute_module</code></strong></p>
<p>选定某个模块功能（比如指定exploit模块里的某个漏洞利用功能）进行执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ret = self.call(<span class="hljs-string">&#x27;module.execute&#x27;</span>, [module_type, module_name, options])<br>job_id = ret[<span class="hljs-string">b&#x27;job_id&#x27;</span>]<br>uuid = ret[<span class="hljs-string">b&#x27;uuid&#x27;</span>].decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>比如一个执行例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">module = <span class="hljs-string">&#x27;exploit/multi/handler&#x27;</span><br>lport = random.randint(<span class="hljs-number">10001</span>, <span class="hljs-number">65535</span>)<br>option = &#123;<span class="hljs-string">&#x27;LHOST&#x27;</span>: self.lhost, <span class="hljs-string">&#x27;LPORT&#x27;</span>: lport, <span class="hljs-string">&#x27;PAYLOAD&#x27;</span>: payload, <span class="hljs-string">&#x27;TARGET&#x27;</span>: <span class="hljs-number">0</span>&#125;<br>job_id, uuid = self.client.execute_module(<span class="hljs-string">&#x27;exploit&#x27;</span>, module, option)<br></code></pre></td></tr></table></figure>



<p><strong><code>get_job_list</code></strong></p>
<p>获取metasploit有哪些任务正在执行，返回一个<code>job_id</code>的列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">jobs = self.call(<span class="hljs-string">&#x27;job.list&#x27;</span>, [])<br>byte_list = jobs.keys()<br>job_list = []<br><span class="hljs-keyword">for</span> job_id <span class="hljs-keyword">in</span> byte_list:<br>    job_list.append(<span class="hljs-built_in">int</span>(job_id.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)))<br></code></pre></td></tr></table></figure>



<p><strong><code>get_job_info</code></strong></p>
<p>指定某个<code>job_id</code>，获取信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.call(<span class="hljs-string">&#x27;job.info&#x27;</span>, [job_id])<br></code></pre></td></tr></table></figure>

<blockquote>
<p>实际上这个函数在程序里根本没有被调用过，也不用了解info都有什么了</p>
</blockquote>
<p><strong><code>stop_job</code></strong></p>
<p>停止某个任务</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.call(<span class="hljs-string">&#x27;job.stop&#x27;</span>, [job_id])<br></code></pre></td></tr></table></figure>



<p><strong><code>get_session_list</code></strong></p>
<p>在metasploit里，session指的是在漏洞利用成功之后，与被攻击系统之间建立的交互式连接或会话。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.call(<span class="hljs-string">&#x27;session.list&#x27;</span>, [])<br></code></pre></td></tr></table></figure>



<p><strong><code>stop_session</code></strong></p>
<p>停止某个session</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.call(<span class="hljs-string">&#x27;session.stop&#x27;</span>, [<span class="hljs-built_in">str</span>(session_id)])<br></code></pre></td></tr></table></figure>



<p><strong><code>stop_meterpreter_session</code></strong></p>
<p>session是建立一个连接，通过shell执行发送过去的命令，Meterpreter可以看作一个特殊的shell</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.call(<span class="hljs-string">&#x27;session.meterpreter_session_detach&#x27;</span>, [<span class="hljs-built_in">str</span>(session_id)])<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Meterpreter和普通shell的区别</p>
<ul>
<li><p>Meterpreter 比系统 shell 更加灵活，功能更加丰富，例如监控主机，监控键盘，开启摄像头，麦克风，还可</p>
<p>以灵活的获取你的操作系统信息。</p>
</li>
<li><p>高级，动态，可扩展的 payload,一站式后攻击 payload；</p>
</li>
<li><p>基于 meterpreter 上下文利用更多漏洞发起攻击；</p>
</li>
<li><p>后渗透测试阶段一站式操作界面；</p>
</li>
<li><p>完全基于内存的 DLL 注入式 payload（不写硬盘）</p>
</li>
<li><p>注入合法系统进程并建立 stager</p>
</li>
<li><p>基于 stager 上传和预加载 DLL 进行扩展模块的注入(客户端 API)</p>
</li>
<li><p>基于 stager 建立的 socket 连接建立加密的 TLS/1.0 通信隧道;</p>
</li>
<li><p>利用 TLS 隧道进一步加载后续扩展模块(避免网络取证</p>
</li>
</ul>
<p>参考自 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xcymn/p/14464945.html">https://www.cnblogs.com/xcymn/p/14464945.html</a></p>
</blockquote>
<p><strong><code>execute_shell</code></strong></p>
<p>指定某个session，在已攻陷的主机上执行指定shell命令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.call(<span class="hljs-string">&#x27;session.shell_write&#x27;</span>, [<span class="hljs-built_in">str</span>(session_id), cmd])<br></code></pre></td></tr></table></figure>



<p><strong><code>get_shell_result</code></strong></p>
<p>获取执行的shell命令的结果（实际程序中没用到这个函数）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.call(<span class="hljs-string">&#x27;session.shell_read&#x27;</span>, [<span class="hljs-built_in">str</span>(session_id), read_pointer])<br></code></pre></td></tr></table></figure>



<p><strong><code>execute_meterpreter</code></strong></p>
<p>和<code>execute_shell</code>一样，针对<code>meterpreter</code>类型session的实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.call(<span class="hljs-string">&#x27;session.meterpreter_write&#x27;</span>, [<span class="hljs-built_in">str</span>(session_id), cmd])<br></code></pre></td></tr></table></figure>



<p><strong><code>execute_meterpreter_run_single</code></strong></p>
<p>（实际程序中没用到这个函数）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.call(<span class="hljs-string">&#x27;session.meterpreter_run_single&#x27;</span>, [<span class="hljs-built_in">str</span>(session_id), cmd])<br></code></pre></td></tr></table></figure>



<p><strong><code>get_meterpreter_result</code></strong></p>
<p>和<code>execute_shell</code>一样，针对<code>meterpreter</code>类型session的实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.call(<span class="hljs-string">&#x27;session.meterpreter_read&#x27;</span>, [<span class="hljs-built_in">str</span>(session_id)])<br></code></pre></td></tr></table></figure>



<p><strong><code>upgrade_shell_session</code></strong></p>
<p>将普通的shell升级为meterpreter</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.call(<span class="hljs-string">&#x27;session.shell_upgrade&#x27;</span>, [<span class="hljs-built_in">str</span>(session_id), lhost, lport])<br></code></pre></td></tr></table></figure>



<p><strong><code>logout</code></strong></p>
<p><strong><code>termination</code></strong></p>
<p>结束与metasploit服务器的通讯</p>
<h4 id="class-Metasploit"><a href="#class-Metasploit" class="headerlink" title="class Metasploit"></a>class Metasploit</h4><p>在<code>Msgrpc</code>类中，定义了许多基本的与服务器交互的操作，在<code>Metasploit</code>类中，介绍了在Deep Exploit中，是如何使用这些基本操作的，即对这些基本操作的更高层次的封装</p>
<p>除了下边介绍的函数，类中还有很多不重要或特别简单的函数，用到的时候会一句话带过</p>
<h5 id="init"><a href="#init" class="headerlink" title="__init__"></a><strong><code>__init__</code></strong></h5><p>这个构造函数的功能按执行顺序列举如下：</p>
<ol>
<li>读取各种配置参数（从config.ini），此处略</li>
<li>创建一个<code>Msgrpc</code>对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.client = Msgrpc(&#123;<span class="hljs-string">&#x27;host&#x27;</span>: server_host, <span class="hljs-string">&#x27;port&#x27;</span>: server_port&#125;)<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>登录并从Metasploit获取一个命令行</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">self.client.login(self.msgrpc_user, self.msgrpc_pass)<br>self.client.get_console()<br></code></pre></td></tr></table></figure>



<div id="get_exploit_tree"></div>

<h5 id="get-exploit-tree"><a href="#get-exploit-tree" class="headerlink" title="get_exploit_tree"></a><strong><code>get_exploit_tree</code></strong></h5><p>exploit tree是一个数据结构，存储 “漏洞-操作系统-这个漏洞针对不同操作系统的payload” 的对应关系</p>
<p>在这个函数中，首先会在<code>data</code>目录下是否有<code>exploit_tree.json</code>文件，如果没有则从服务器获取exploit tree，否则就从这个文件读取</p>
<p>从本地读取的代码很简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> os.path.exists(os.path.join(self.data_path, <span class="hljs-string">&#x27;exploit_tree.json&#x27;</span>)) <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>    ...<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># Get exploit tree from local file.</span><br>    local_file = os.path.join(self.data_path, <span class="hljs-string">&#x27;exploit_tree.json&#x27;</span>)<br>    self.util.print_message(OK, <span class="hljs-string">&#x27;Loaded exploit tree from : &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(local_file))<br>    fin = codecs.<span class="hljs-built_in">open</span>(local_file, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    exploit_tree = json.loads(fin.read().replace(<span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))<br>    fin.close()<br><span class="hljs-keyword">return</span> exploit_tree<br></code></pre></td></tr></table></figure>

<p>如果本地没有这个文件，就需要向服务器查询。查询的过程是，首先使用<code>use</code>命令，指定某个漏洞，然后使用<code>show targets</code>，列出受该漏洞影响的所有系统类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> idx, exploit <span class="hljs-keyword">in</span> tqdm.tqdm(<span class="hljs-built_in">enumerate</span>(com_exploit_list)):<br>    temp_target_tree = &#123;<span class="hljs-string">&#x27;targets&#x27;</span>: []&#125;<br>    temp_tree = &#123;&#125;<br>    <span class="hljs-comment"># Set exploit module.</span><br>    use_cmd = <span class="hljs-string">&#x27;use exploit/&#x27;</span> + exploit + <span class="hljs-string">&#x27;\n&#x27;</span><br>    _ = self.client.send_command(self.client.console_id, use_cmd, <span class="hljs-literal">False</span>)<br><br>    <span class="hljs-comment"># Get target.</span><br>    show_cmd = <span class="hljs-string">&#x27;show targets\n&#x27;</span><br>    <br>    ...<br>    <br>    target_info = self.client.send_command(self.client.console_id, show_cmd, <span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>

<p>比如<code>show targets</code>的一个例子如下图所示：</p>
<p><img src="/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DeepExploit/1.png" srcset="/img/loading.gif" lazyload alt="image-20240604235856559"></p>
<p>接下来，根据每个<code>target</code>，获取对应的<code>payload</code> （参数里的exploit是一个具体的漏洞，target是一个编号）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">payload_list = self.client.get_target_compatible_payload_list(exploit, <span class="hljs-built_in">int</span>(target))<br>temp_tree[target] = payload_list<br></code></pre></td></tr></table></figure>

<p>也就是从这里开始，才看出来，这个函数为什么叫做<code>tree</code>，这里的<code>temp_tree</code>就是一颗每个叶节点都是针对不同平台的payload的树。</p>
<p>接下来获取每个漏洞的options，即这个漏洞利用前需要做的配置</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">options</span> = self.client.get_module_options(<span class="hljs-string">&#x27;exploit&#x27;</span>, exploit)<br></code></pre></td></tr></table></figure>

<p>以下是漏洞的options的一个例子，会显示哪些参数是必须手动设置的</p>
<p><img src="/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DeepExploit/2.png" srcset="/img/loading.gif" lazyload alt="image-20240605001159272"></p>
<p>然后这些options也会组织成一个字典的形式，结合前面的payload的树，最终合并成一个树，也就是<code>exploit_tree</code>，会把它存储在<code>data</code>目录下的<code>exploit_tree.json</code>中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">temp_target_tree[<span class="hljs-string">&#x27;target_list&#x27;</span>] = target_list<br>temp_target_tree[<span class="hljs-string">&#x27;targets&#x27;</span>] = temp_tree<br>temp_target_tree[<span class="hljs-string">&#x27;options&#x27;</span>] = option<br>exploit_tree[exploit] = temp_target_tree<br></code></pre></td></tr></table></figure>

<p>这个文件的示例如下</p>
<p><img src="/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DeepExploit/3.png" srcset="/img/loading.gif" lazyload alt="image-20240605004141948"></p>
<div id="get_target_info"></div>

<h5 id="get-target-info"><a href="#get-target-info" class="headerlink" title="get_target_info"></a><strong><code>get_target_info</code></strong></h5><p>在不指定端口的情况下，获取目标主机所有端口上运行服务的详细信息（比如版本）</p>
<p>代码结构同样是如果本地有这个主机的记录就从本地读取，没有就让Metasploit服务器扫描分析</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> os.path.exists(os.path.join(self.data_path, <span class="hljs-string">&#x27;target_info_&#x27;</span> + rhost + <span class="hljs-string">&#x27;.json&#x27;</span>)) <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>    ...<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># Get target host information from local file.</span><br>    saved_file = os.path.join(self.data_path, <span class="hljs-string">&#x27;target_info_&#x27;</span> + rhost + <span class="hljs-string">&#x27;.json&#x27;</span>)<br>    self.util.print_message(OK, <span class="hljs-string">&#x27;Loaded target tree from : &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(saved_file))<br>    fin = codecs.<span class="hljs-built_in">open</span>(saved_file, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    target_tree = json.loads(fin.read().replace(<span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))<br>    fin.close()<br><span class="hljs-keyword">return</span> target_tree<br></code></pre></td></tr></table></figure>

<p>如果本地没有记录，则会开始分析</p>
<p>首先会检查一下开放的这些端口里有没有http或https协议：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Check web port.</span><br>web_port_list = self.util.check_web_port(rhost, com_port_list, self.client)<br></code></pre></td></tr></table></figure>

<p>对检测到的http或https协议，通过爬虫获取网站的内容（递归扫描资源路径）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">web_target_info = self.util.run_spider(rhost, web_port_list, self.client)<br></code></pre></td></tr></table></figure>

<p>这个<code>run_spider</code>调用scrapy命令，以下是其内部的实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">result_file = os.path.join(self.output_base_path, now_time + self.output_filename)<br>option = <span class="hljs-string">&#x27; -a target_url=&#x27;</span> + target_url + <span class="hljs-string">&#x27; -a allow_domain=&#x27;</span> + target_ip + \<br>         <span class="hljs-string">&#x27; -a concurrent=&#x27;</span> + self.spider_concurrent_reqs + <span class="hljs-string">&#x27; -a depth_limit=&#x27;</span> + self.spider_depth_limit + \<br>         <span class="hljs-string">&#x27; -a delay=&#x27;</span> + self.spider_delay_time + <span class="hljs-string">&#x27; -a store_path=&#x27;</span> + self.store_path + \<br>         <span class="hljs-string">&#x27; -a response_log=&#x27;</span> + response_log + <span class="hljs-string">&#x27; -a msgrpc_host=&#x27;</span> + client.host + \<br>         <span class="hljs-string">&#x27; -a msgrpc_port=&#x27;</span> + <span class="hljs-built_in">str</span>(client.port) + <span class="hljs-string">&#x27; -a msgrpc_token=&#x27;</span> + client.token.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>) + \<br>         <span class="hljs-string">&#x27; -a msgrpc_console_id=&#x27;</span> + client.console_id.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>) + <span class="hljs-string">&#x27; -o &#x27;</span> + result_file<br>close_opton = <span class="hljs-string">&#x27; -s CLOSESPIDER_TIMEOUT=&#x27;</span> + self.spider_time_out + \<br>              <span class="hljs-string">&#x27; -s CLOSESPIDER_ITEMCOUNT=&#x27;</span> + self.spider_item_count + \<br>              <span class="hljs-string">&#x27; -s CLOSESPIDER_PAGECOUNT=&#x27;</span> + self.spider_page_count + \<br>              <span class="hljs-string">&#x27; -s CLOSESPIDER_ERRORCOUNT=&#x27;</span> + self.spider_error_count + <span class="hljs-string">&#x27; &#x27;</span><br>command = <span class="hljs-string">&#x27;scrapy runspider&#x27;</span> + close_opton + <span class="hljs-string">&#x27;Spider.py&#x27;</span> + option<br></code></pre></td></tr></table></figure>

<p><code>scrapy</code>命令会在<code>crawl_result</code>文件夹下存储这个扫描结果的输出，<code>run_spider</code>以列表的形式返回这些网站内容。（因为网站可能有很多不同的资源路径）</p>
<p>接下来就会分析服务的版本信息，使用了两种不同的方法，一种是基于签名的识别，一种是基于机器学习的识别</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Check product name/version using signature.</span><br>web_prod_list.extend(version_checker.get_product_name(parsed, res_header + res_body, self.client))<br><span class="hljs-comment"># Check product name/version using Machine Learning.</span><br>web_prod_list.extend(version_checker_ml.get_product_name(parsed, res_header + res_body, self.client))<br></code></pre></td></tr></table></figure>

<p>基于签名的识别比较简单，在<code>signature/signature_product.txt</code>文件中，会存有一系列的正则表达式</p>
<p><img src="/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DeepExploit/4.png" srcset="/img/loading.gif" lazyload alt="image-20240605132748525"></p>
<p><code>version_checker.get_product_name</code>中，会使用这些正则表达式是用来匹配写在http响应的header和body中，程序及版本信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">obj_match = re.search(signature, response, flags=re.IGNORECASE)<br></code></pre></td></tr></table></figure>

<p>另一种是基于Naive Bayes的识别，既然是基于朴素贝叶斯的算法，那就一定要有一些数据，来计算先验概率，对于这一点，<code>version_checkerML.get_product_name</code>就使用了<code>modules/train_data/train_cms.txt</code>中的内容进行了训练。（这里的train和命令行参数指定的无关，也就是无论是train模式还是test模式，这里都需要训练一个先验概率出来，而且是每次执行都要训练一遍train_cms.txt的内容）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">elif</span> category == <span class="hljs-string">&#x27;CMS&#x27;</span>:<br>    nb = self.train(self.train_cms_in, self.train_cms_out)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>其实，config.ini中会指定一个要预测的product category，比如CMS、比如OS、比如Middleware。config.ini 默认指定的是CMS，并且train_data文件夹下只提供了cms的训练数据，而且train_cms.txt也只有六行训练数据，真的要实际使用Deep Exploit需要补充数据和类别。</p>
</blockquote>
<p>在train函数中，调用了<code>module\NaiveBayes.py</code>。训练之后就用这个分类器预测一下目标服务，给出标签。</p>
<p>这是<code>train_cms.txt</code>原本的内容，@分割之后，最后一列是训练数据，第一列是标签</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mel">joomla@joomla\!@*@(Set-Cookie: [a-z0<span class="hljs-number">-9</span>]&#123;<span class="hljs-number">32</span>&#125;=.*);<br>joomla@joomla\!@*@(Set-Cookie: .*=[a-z0<span class="hljs-number">-9</span>]&#123;<span class="hljs-number">26</span>,<span class="hljs-number">32</span>&#125;);<br>heartcore@heartcore@*@(Set-Cookie:.*=[A-Z0<span class="hljs-number">-9</span>]&#123;<span class="hljs-number">32</span>&#125;);.*<br>heartcore@heartcore@*@(&lt;meta name=[<span class="hljs-string">&quot;&#x27;]author[&quot;</span><span class="hljs-string">&#x27;] content=[&quot;&#x27;</span>]&#123;<span class="hljs-number">2</span>&#125;).*<br>wordpress@wordpress@*@(X-Pingback):.*xmlrpc.php[\r\n]<br>wordpress@wordpress@*@(&lt;body class=[<span class="hljs-string">&quot;&#x27;]home ).*</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>除了<code>version_checker.get_product_name</code> 和 <code>version_checkerML.get_product_name</code>，代码中还有一个叫做基于“default content”的识别方法<code>content_explorer</code>，这个方法和version checker 的区别在于，version checker 只是用 http响应的header和body进行搜索，content explorer 使用完整的http报文，但还是基于签名的识别</p>
</blockquote>
<p>以上是获取产品名及其版本的步骤，最终要得到的是如下形式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">temp_tree = &#123;<span class="hljs-string">&#x27;prod_name&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;version&#x27;</span>: <span class="hljs-number">0.0</span>, <span class="hljs-string">&#x27;protocol&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;target_path&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;exploit&#x27;</span>: []&#125;<br></code></pre></td></tr></table></figure>

<p><code>protocol</code> 是之前nmap扫描结果里的协议版本，比如tcp，<code>target_path</code>是这个网站上有哪些资源路径，exploit则是通过在Metasploit服务器上搜索这个程序的漏洞的结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">search_cmd = <span class="hljs-string">&#x27;search name:&#x27;</span> + service_name + <span class="hljs-string">&#x27; type:exploit app:server\n&#x27;</span><br>raw_module_info = self.client.send_command(self.client.console_id, search_cmd, <span class="hljs-literal">False</span>, <span class="hljs-number">3.0</span>)<br></code></pre></td></tr></table></figure>

<p>针对每一个端口的<code>temp_tree</code>合起来就是最终的返回结果就是<code>target_tree</code></p>
<div id="get_target_info_candidate"></div>

<h5 id="get-target-info-indicate"><a href="#get-target-info-indicate" class="headerlink" title="get_target_info_indicate"></a><strong><code>get_target_info_indicate</code></strong></h5><p>功能和<a href="#get_target_info"><code>get_target_info</code> </a>一致，只不过因为指定了目标端口和服务名称，不会再扫描目标主机，返回结果和上一个函数相比只是少了 <code>target_path</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">temp_tree = &#123;<span class="hljs-string">&#x27;prod_name&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;version&#x27;</span>: <span class="hljs-number">0.0</span>, <span class="hljs-string">&#x27;protocol&#x27;</span>: <span class="hljs-string">&#x27;tcp&#x27;</span>, <span class="hljs-string">&#x27;exploit&#x27;</span>: []&#125;<br></code></pre></td></tr></table></figure>

<p><code>prod_name</code>是直接从命令行参数copy过来的，version 也不会检测，直接被赋值成0.0，protocol直接被赋值成tcp，exploit部分依旧和前一个函数一模一样。</p>
<h5 id="extract-osmatch-module"><a href="#extract-osmatch-module" class="headerlink" title="extract_osmatch_module"></a><strong><code>extract_osmatch_module</code></strong></h5><p>在<a href="#get_target_info"><code>get_target_info</code> </a>中被调用，用来匹配漏洞是否适配于某个操作系统版本</p>
<div id="execute_nmap"></div>

<h5 id="execute-nmap"><a href="#execute-nmap" class="headerlink" title="execute_nmap"></a><strong><code>execute_nmap</code></strong></h5><p>nmap是由服务器端执行的，通过<code>console.write</code>命令，让Metasploit执行一个控制台命令，命令是由<code>config.ini</code>中写好的nmap指令和参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.client.call(<span class="hljs-string">&#x27;console.write&#x27;</span>, [self.client.console_id, command])<br></code></pre></td></tr></table></figure>

<p>端口扫描的结果会以xml的格式保存，（这个xml文件会保存在服务器端，但是在测试的时候服务器端和客户端用的是同一主机）</p>
<p><img src="/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DeepExploit/5.png" srcset="/img/loading.gif" lazyload alt="image-20240603212141699"></p>
<p>这个函数只是让服务器端进行了端口扫描，将结果传回客户端是由下一个函数<code>get_port_list</code>执行的。</p>
<div id="get_port_list"></div>

<h5 id="get-port-list"><a href="#get-port-list" class="headerlink" title="get_port_list"></a><strong><code>get_port_list</code></strong></h5><p>这个函数会在程序执行 <a href="#execute_nmap">execute_nmap</a> 之后运行，函数参数中，会传入nmap扫描之后，保存到本地的文件路径。并且会在<code>data</code>目录下检索是否之前获取过这个ip的端口列表，如果之前有记录，则直接读取结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> os.path.exists(os.path.join(self.data_path, <span class="hljs-string">&#x27;target_info_&#x27;</span> + rhost + <span class="hljs-string">&#x27;.json&#x27;</span>)) <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>    ...<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># Get target host information from local file.</span><br>    saved_file = os.path.join(self.data_path, <span class="hljs-string">&#x27;target_info_&#x27;</span> + rhost + <span class="hljs-string">&#x27;.json&#x27;</span>)<br>    self.util.print_message(OK, <span class="hljs-string">&#x27;Loaded target tree from : &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(saved_file))<br>    fin = codecs.<span class="hljs-built_in">open</span>(saved_file, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    target_tree = json.loads(fin.read().replace(<span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))<br>    fin.close()<br>    key_list = <span class="hljs-built_in">list</span>(target_tree.keys())<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> key_list[<span class="hljs-number">2</span>:]:<br>        port_list.append(<span class="hljs-built_in">str</span>(key))<br>        <span class="hljs-comment"># Update com_port_list.</span><br>    com_port_list = port_list<br><span class="hljs-keyword">return</span> port_list, proto_list, info_list<br></code></pre></td></tr></table></figure>

<p>如果之前没有，则会向服务器进行查询（也就是读取<a href="#execute_nmap"><code>execute_nmap</code></a>的执行结果文件）</p>
<p>通过发送一个<code>cat</code>命令，将xml文件内容读取发送回客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">cat_cmd = <span class="hljs-string">&#x27;cat &#x27;</span> + nmap_result_file + <span class="hljs-string">&#x27;\n&#x27;</span><br>_ = self.client.call(<span class="hljs-string">&#x27;console.write&#x27;</span>, [self.client.console_id, cat_cmd])<br><br>...<br><br>ret = self.client.call(<span class="hljs-string">&#x27;console.read&#x27;</span>, [self.client.console_id])<br><br>...<br></code></pre></td></tr></table></figure>

<p>返回给客户端的结果包含：端口号、协议、程序/服务名、版本等，还有对目标主机操作系统的识别结果</p>
<p>然后存入本地<code>data/target_info_&lt;ip&gt;.json</code>中</p>
<div id="get_exploit_list"></div>

<h5 id="get-exploit-list"><a href="#get-exploit-list" class="headerlink" title="get_exploit_list"></a><strong><code>get_exploit_list</code></strong></h5><p>首先会在<code>data</code>目录下检查是否有<code>exploit_list.csv</code>文件，没有则向服务器查询，有则直接读取</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> os.path.exists(os.path.join(self.data_path, <span class="hljs-string">&#x27;exploit_list.csv&#x27;</span>)) <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>    ...<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># Get exploit module list from local file.</span><br>    local_file = os.path.join(self.data_path, <span class="hljs-string">&#x27;exploit_list.csv&#x27;</span>)<br>    self.util.print_message(OK, <span class="hljs-string">&#x27;Loaded exploit list from : &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(local_file))<br>    fin = codecs.<span class="hljs-built_in">open</span>(local_file, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> fin:<br>        all_exploit_list.append(item.rstrip(<span class="hljs-string">&#x27;\n&#x27;</span>))<br>        fin.close()<br><span class="hljs-keyword">return</span> all_exploit_list<br></code></pre></td></tr></table></figure>

<p>如果是从服务器请求，是通过 <a href="#get_module_list">Msgrpc.get_module_list</a> 函数来获取的，遍历exploit 模块下的所有漏洞</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">exploit_candidate_list = self.client.get_module_list(<span class="hljs-string">&#x27;exploit&#x27;</span>)<br><span class="hljs-keyword">for</span> idx, exploit <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(exploit_candidate_list):<br>    module_info = self.client.get_module_info(<span class="hljs-string">&#x27;exploit&#x27;</span>, exploit)<br>    ......<br></code></pre></td></tr></table></figure>

<p>将获取到的漏洞列表存入<code>exploit_list.csv</code>中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Save Exploit module list to local file.</span><br>self.util.print_message(OK, <span class="hljs-string">&#x27;Total loaded exploit module: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(all_exploit_list))))<br>fout = codecs.<span class="hljs-built_in">open</span>(os.path.join(self.data_path, <span class="hljs-string">&#x27;exploit_list.csv&#x27;</span>), <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> all_exploit_list:<br>    fout.write(item + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>fout.close()<br>self.util.print_message(OK, <span class="hljs-string">&#x27;Saved exploit list.&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>在本地测试之后，生成csv的内容如下</p>
<p><img src="/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DeepExploit/6.png" srcset="/img/loading.gif" lazyload alt="image-20240603214528514"></p>
<p>可以看到它其实并不是逗号分隔符文件</p>
<div id="get_payload_list"></div>

<h5 id="get-payload-list"><a href="#get-payload-list" class="headerlink" title="get_payload_list"></a><strong><code>get_payload_list</code></strong></h5><p>代码形式和 前一个 <strong><code>get_exploit_list</code></strong> 一致，只不过是把获取漏洞改成获取payload，同样存到一个csv（payload_list.csv）中</p>
<p><img src="/img/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DeepExploit/7.png" srcset="/img/loading.gif" lazyload alt="image-20240603215323947"></p>
<h5 id="execute-exploit"><a href="#execute-exploit" class="headerlink" title="execute_exploit"></a><strong><code>execute_exploit</code></strong></h5><p>这个函数是在测试或训练时，运行那些在<code>Agent.act</code>中给出的根据概率排好序的payload，即测试这些神经网络给出的payload能否正确运行。</p>
<div id="execute_post_exploit"></div>

<h5 id="execute-post-exploit"><a href="#execute-post-exploit" class="headerlink" title="execute_post_exploit"></a><strong><code>execute_post_exploit</code></strong></h5><p><code>execute_post_list</code>会在<code>execute_exploit</code>测试之后，对那些成功执行了的payload（即拿到了Metasploit的session_id），在其上运行<code>arp</code>命令，探测它们所在的内部网络中的其他主机信息（即<code>get_internal_ip</code>函数）</p>
<p>然后<code>set_pivoting</code>会通过 <code>run get_local_subnets</code> 命令 获得子网信息，通过<code>run autoroute</code>命令 将主机作为跳板</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Search other servers in internal network.</span><br>internal_ip_list, _ = self.get_internal_ip(session_id)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(internal_ip_list) == <span class="hljs-number">0</span>:<br>    self.util.print_message(WARNING, <span class="hljs-string">&#x27;Internal server is not found.&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># Pivoting.</span><br>    self.util.print_message(OK, <span class="hljs-string">&#x27;Internal server list.\n&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(internal_ip_list))<br>    self.set_pivoting(session_id, internal_ip_list)<br></code></pre></td></tr></table></figure>

<p><code>execute_post_exploit</code>会返回这些内网IP，而且这个函数<strong>只会在test模式下被调用</strong>，后面会对子网内的设备进行渗透测试</p>
<h4 id="class-ParameterServer"><a href="#class-ParameterServer" class="headerlink" title="class ParameterServer"></a>class ParameterServer</h4><div id="_build_model"></div>
##### **`_build_model`**

<p>定义了网络结构</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_build_model</span>(<span class="hljs-params">self</span>):<br>    l_input = Input(batch_shape=(<span class="hljs-literal">None</span>, NUM_STATES))<br>    l_dense1 = Dense(<span class="hljs-number">50</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>)(l_input)<br>    l_dense2 = Dense(<span class="hljs-number">100</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>)(l_dense1)<br>    l_dense3 = Dense(<span class="hljs-number">200</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>)(l_dense2)<br>    l_dense4 = Dense(<span class="hljs-number">400</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>)(l_dense3)<br>    out_actions = Dense(NUM_ACTIONS, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>)(l_dense4)<br>    out_value = Dense(<span class="hljs-number">1</span>, activation=<span class="hljs-string">&#x27;linear&#x27;</span>)(l_dense4)<br>    model = Model(inputs=[l_input], outputs=[out_actions, out_value])<br>    <span class="hljs-keyword">return</span> model<br></code></pre></td></tr></table></figure>

<p>网络很简单，前四层就是普通的全连接，<code>out_actions</code>是强化学习中，在给定状态下采取每个可能动作的概率，<code>out_value</code>是对应的奖励值</p>
<p>但是最终模型要copy到<code>LocalBrain</code>中，进行训练或测试（见<a href="#LocalBrain"><code>LocalBrain</code></a>）</p>
<div id="LocalBrain"></div>
#### class Agent & LocalBrain & Environment

<p>这三者放在一起分析，顾名思义，就是强化学习中，用来执行操作的智能体（Agent）、帮智能体决策的大脑（LocalBrain）、反馈奖励的外部环境（Environment）</p>
<div id="environment_run"></div>
##### **`Environment.run`**

<p>首先介绍 <strong>test部分</strong></p>
<p>由<code>WorkerThread.run</code>直接调用，在这个环境（Environment）中，第一步就是创建一个Agent，这个Agent又有自己的大脑（LocalBrain），模型参数会传入大脑中。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">self<span class="hljs-selector-class">.agent</span><span class="hljs-selector-class">.brain</span><span class="hljs-selector-class">.pull_parameter_server</span>()<br></code></pre></td></tr></table></figure>

<p>接下来要遍历<code>target_tree</code>中的漏洞列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> port_num <span class="hljs-keyword">in</span> com_port_list:<br>    execute_list = []<br>    target_info = &#123;&#125;<br>    module_list = target_tree[port_num][<span class="hljs-string">&#x27;exploit&#x27;</span>]<br>    <span class="hljs-keyword">for</span> exploit <span class="hljs-keyword">in</span> module_list:<br>        target_list = exploit_tree[exploit[<span class="hljs-number">8</span>:]][<span class="hljs-string">&#x27;target_list&#x27;</span>] <br>        <span class="hljs-comment"># 从8开始是去掉字符串前缀 &#x27;exploit/&#x27; ， 后续使用漏洞时的命令不包含这个前缀</span><br>        <span class="hljs-comment"># 比如&#x27;exploit/windows/smb/eternalblue&#x27; -&gt; &#x27;windows/smb/eternalblue&#x27;</span><br></code></pre></td></tr></table></figure>

<p>把漏洞交给Agent去探索利用方法，即<code>agent.act</code>函数，提供的信息有状态（<code>s</code>）当前可以执行的payload（<code>available_actions</code>）和 贪婪策略（<code>eps_steps</code>）（见<a href="#agent_act"><code>Agent.act</code></a>）</p>
<blockquote>
<p>这里的状态s包括 操作系统类型、服务名、版本、可利用的漏洞、漏洞能够影响的操作系统版本，<strong>这也就是后面神经网络的输入</strong></p>
</blockquote>
<blockquote>
<p>这里的eps_steps指的是 训练周期数 * 贪婪率。一开始是采取随机的执行策略，当达到这个eps_step的步数时，就开始一直尝试最优的策略</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> target <span class="hljs-keyword">in</span> target_list:<br>    skip_flag, s, payload_list, target_info = self.env.get_state(exploit_tree, target_tree,  port_num, exploit,target)<br>    <span class="hljs-keyword">if</span> skip_flag <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>        <span class="hljs-comment"># Get available payload index.</span><br>        available_actions = self.env.get_available_actions(payload_list)<br><br>        <span class="hljs-comment"># Decide action using epsilon greedy.</span><br>        frames = self.env.eps_steps<br>        _, _, p_list = self.agent.act(s, available_actions, self.env.eps_steps)<br>        <span class="hljs-comment"># Append all payload probabilities.</span><br>        <span class="hljs-keyword">if</span> p_list <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">for</span> prob <span class="hljs-keyword">in</span> p_list:<br>                execute_list.append([prob[<span class="hljs-number">1</span>], exploit, target, prob[<span class="hljs-number">0</span>], target_info])<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure>

<p>在test中，根据<code>Agent.act</code>返回的已经根据概率排好序的payload，逐个进行测试，测试的过程分两步<code>execute_exploit</code> 和 <code>execute_post_exploit</code></p>
<p>前者会测试这些payload能不能正确运行，后者会对成功攻击的主机作为跳板，探测其内网主机ip（见<a href="#execute_post_exploit"><code>Metasploit.execute_post_exploit</code></a>）</p>
<blockquote>
<p>这个第二步在train模式下是没有的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> idx, exe_info <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(execute_list):<br>    <span class="hljs-comment"># Execute exploit.</span><br>    _, _, done, sess_info = self.env.execute_exploit(exe_info[<span class="hljs-number">3</span>], self.name, self.thread_type, exe_info[<span class="hljs-number">2</span>], exe_info[<span class="hljs-number">4</span>], idx, exploit_tree)<br></code></pre></td></tr></table></figure>

<p>那如何利用跳板对内网发起攻击？</p>
<p>首先通过metasploit的辅助模块中<code>socks4a</code>做了一个代理，然后通过<code>deep_run</code>对内网主机进行分析</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">module = <span class="hljs-string">&#x27;auxiliary/server/socks4a&#x27;</span><br>self.util.print_message(NOTE, <span class="hljs-string">&#x27;Set proxychains: SRVHOST=&#123;&#125;, SRVPORT=                                                   &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.env.proxy_host, <span class="hljs-built_in">str</span>(self.env.proxy_port)))<br>option = &#123;<span class="hljs-string">&#x27;SRVHOST&#x27;</span>: self.env.proxy_host, <span class="hljs-string">&#x27;SRVPORT&#x27;</span>: self.env.proxy_port&#125;<br>job_id, uuid = self.env.client.execute_module(<span class="hljs-string">&#x27;auxiliary&#x27;</span>, module, option)<br><br>...<br><br>self.deep_run(new_target_list)<br></code></pre></td></tr></table></figure>

<p><code>deep_run</code>依旧是通过nmap获取主机端口，建立<code>exploit_tree</code>和<code>target_tree</code>，然后反过来条用<code>run</code>函数，形成了一个递归嵌套的调用结构，直到找不到任何内网主机</p>
<p>而<code>train</code>部分就没有这个嵌套过程，不会对检测目标主机是否存在内网，和test不同的部分只是多了一些训练模型参数的代码。</p>
<p>train模式下，在通过<code>execute_exploit</code>验证模型给出的 “概率最大的payload” 的正确性之后（其余的payload都不考虑），会计算奖励，奖励的计算方法就是攻击成功，奖励值加一个固定值。通过 <a href="#advantage_push_local_brain"><code>advantage_push_local_brain</code> </a>去更新LocalBrain中的参数。</p>
<div id="agent_act"></div>
##### **`Agent.act`**

<p>在<code>Environment.run</code>中，会把当前状态和可供选择的操作传过来</p>
<p>agent会让大脑（中的神经网络）给出对于状态s的预测值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p = self.brain.predict_p(s)<br></code></pre></td></tr></table></figure>

<p>输出的结果<code>p</code>是一系列的概率，即针对<code>available_action_list</code>中的每一种payload 给出一个概率值，然后根据概率大小进行排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> available_action_list:<br>    prob.append([action, p[<span class="hljs-number">0</span>][action]])<br>prob.sort(key=<span class="hljs-keyword">lambda</span> s: -s[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">return</span> prob[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], prob[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], prob<br></code></pre></td></tr></table></figure>

<blockquote>
<p>神经网络的输出的shape不是一个固定的值，它的长度取决于有多少种可供选择的action</p>
</blockquote>
<div id="advantage_push_local_brain"></div>
##### **`Agent.advantage_push_local_brain`**

<p>将经验数据（包括状态、动作、奖励和下一个状态）推送到 <code>LocalBrain</code> 的训练队列中</p>
<p>首先使用 Bellman 方程来计算优势值</p>
<blockquote>
<p>优势值表示了实际获得的奖励与预期奖励（由当前策略估计的价值函数）之间的差异。</p>
</blockquote>
<p>然后将这些经验数据和优势值一起存储在 <code>LocalBrain</code> 的训练队列 <code>train_queue</code> 中。这个队列以批量的形式累积数据，直到达到一定的大小 <code>MIN_BATCH</code>。</p>
<p>当训练队列中的数据量达到 <code>MIN_BATCH</code> 或者在每个时间步后，<code>LocalBrain</code> 会从队列中取出数据，计算梯度，并更新其神经网络的参数。</p>
<h4 id="class-WorkerThread"><a href="#class-WorkerThread" class="headerlink" title="class WorkerThread"></a>class WorkerThread</h4><p>这个类代表着一个训练线程或测试线程，由它去调用<code>Environment.run</code>，那里才是真正的强化学习执行代码</p>
<div id="run"></div>
##### **`run`**

<div id="run"></div>
根据构造函数时的`threat_type`参数来判断是训练还是测试

<p>无论是train或test，都是一个死循环，靠<code>isFinish</code>这个全局变量控制循环的结束</p>
<p>在test中，只调用了一个<code>Environment.run</code>，（见 <a href="#environment_run"><code>Environment.run</code></a>），（生成报告的部分是train和test相同的），如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">self.environment.run(exploit_tree, target_tree)<br><span class="hljs-comment"># Stop testing thread.</span><br><span class="hljs-keyword">if</span> isFinish:<br>    self.util.print_message(OK, <span class="hljs-string">&#x27;Finish test.&#x27;</span>)<br>    time.sleep(<span class="hljs-number">3.0</span>)<br>    <span class="hljs-comment"># Disconnection RPC Server.</span><br>    self.environment.env.client.termination(self.environment.env.client.console_id)<br>    <span class="hljs-comment"># Create report.</span><br>    report = CreateReport()<br>    report.create_report(<span class="hljs-string">&#x27;test&#x27;</span>, pd.to_datetime(self.environment.env.scan_start_time))<br>    <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>

<p>而train部分也只是比test部分多了一个画训练过程图的部分，不多做解释，重点也在<a href="#environment_run"><code>Environment.run</code></a>中。</p>
<h2 id="三-程序执行流程"><a href="#三-程序执行流程" class="headerlink" title="三. 程序执行流程"></a>三. 程序执行流程</h2><ol>
<li><p>解析命令行参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">rhost, mode, port, service = command_parse()<br></code></pre></td></tr></table></figure></li>
<li><p>根据rhost创建一个<code>Metasploit</code>对象，对目标主机进行端口扫描</p>
<p>见（<a href="#get_port_list">Metasploit.get_port_list</a>、<a href="#execute_nmap">Metasploit.execute_nmap</a>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">env = Metasploit(rhost)<br>...<br>env.execute_nmap(env.rhost, nmap_command, env.nmap_timeout)<br>com_port_list, proto_list, info_list = env.get_port_list(nmap_result, env.rhost)<br></code></pre></td></tr></table></figure></li>
<li><p>获取Metasploit的漏洞列表，存储在<code>data/exploit_list.csv</code>中（见 <a href="#get_exploit_list">Metasploit.get_exploit_list</a>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">com_exploit_list = env.get_exploit_list()<br></code></pre></td></tr></table></figure></li>
<li><p>获取Metasploit的payload列表，存储在<code>data/payload_list.csv</code>中（见 <a href="#get_payload_list">Metasploit.get_payload_list</a>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">com_payload_list = env.get_payload_list()<br></code></pre></td></tr></table></figure></li>
<li><p>获取exploit_tree，这里面包含每个漏洞在不同操作系统下的不同payload（见 <a href="#get_exploit_tree">Metasploit.get_exploit_tree</a>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">exploit_tree = env.get_exploit_tree()<br></code></pre></td></tr></table></figure></li>
<li><p>这步操作是在检查目标主机的服务和端口信息。<code>check_port_value</code>函数是检查用户在客户端命令行参数输入的端口和服务是否合法（即检查port是不是0-65535，是否是前面nmap扫描到的端口之一），返回一个true/false。但实际上，更多的情况是由于没有指定端口和服务，从而产生的接下来的分支</p>
<p><code>get_target_info</code>：获取目标主机所有端口上的程序的信息（见<a href="#get_target_info">Metasploit.get_target_info</a>）最终结果包括有哪些服务，服务版本是什么，有哪些资源路径，有哪些漏洞可以攻击它。</p>
<p><code>get_target_info_indicate</code>：只分析指定的端口（见<a href="#get_target_info_indicate">Metasploit.get_target_info_indicate</a>）</p>
<blockquote>
<p>在这一步的实现中，Deep Exploit使用了两种方法对目标主机进行识别，一种是基于指纹的识别，一种是基于Naive Bayes算法的识别</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">com_indicate_flag = check_port_value(port, service) <br><span class="hljs-keyword">if</span> com_indicate_flag:<br>    target_tree, com_port_list = env.get_target_info_indicate(rhost, proto_list, info_list, port, service)<br><span class="hljs-keyword">else</span>:<br>    target_tree = env.get_target_info(rhost, proto_list, info_list)<br></code></pre></td></tr></table></figure></li>
<li><p>准备训练/测试</p>
<p>从这里开始才体现出参数中的<code>train/test</code>的作用，<code>config.ini</code>中定义了训练的线程数量是20，测试的线程数量是1。</p>
<p>在ParameterServer中定义了强化学习的网络结构，见<a href="#_build_model"><code>ParameterServer._build_model</code></a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> tf.device(<span class="hljs-string">&quot;/cpu:0&quot;</span>):<br>    parameter_server = ParameterServer()<br>    threads = []<br><br>    <span class="hljs-keyword">if</span> mode == <span class="hljs-string">&#x27;train&#x27;</span>:<br>        <span class="hljs-comment"># Create learning thread.</span><br>        <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(TRAIN_WORKERS):<br>            thread_name = <span class="hljs-string">&#x27;local_thread&#x27;</span> + <span class="hljs-built_in">str</span>(idx + <span class="hljs-number">1</span>)<br>            threads.append(Worker_thread(thread_name=thread_name,<br>                                            thread_type=<span class="hljs-string">&quot;learning&quot;</span>,<br>                                            parameter_server=parameter_server,<br>                                            rhost=rhost))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># Create testing thread.</span><br>        <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(TEST_WORKER):<br>            thread_name = <span class="hljs-string">&#x27;local_thread1&#x27;</span><br>            threads.append(Worker_thread(thread_name=thread_name,<br>                                            thread_type=<span class="hljs-string">&quot;test&quot;</span>,<br>                                            parameter_server=parameter_server,<br>                                            rhost=rhost))<br></code></pre></td></tr></table></figure></li>
<li><p>训练/测试。模型参数会被保存在<code>trained_data</code>目录下。训练和测试的具体过程见 <a href="#run"><code>WorkerThread.run</code></a></p>
<p> 概括来说，用到的神经网络的功能就是：输入（操作系统类型、服务名、版本、可利用的漏洞、漏洞能够影响的操作系统版本），输出一串概率，对应每个可利用漏洞的成功概率。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> mode == <span class="hljs-string">&#x27;train&#x27;</span>:<br>    <span class="hljs-comment"># Load past learned data.</span><br>    <span class="hljs-keyword">if</span> os.path.exists(env.save_file) <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># Restore learned model from local file.</span><br>        util.print_message(OK, <span class="hljs-string">&#x27;Restore learned data.&#x27;</span>)<br>        saver.restore(SESS, env.save_file)<br><br>    <span class="hljs-comment"># Execute learning.</span><br>    <span class="hljs-keyword">for</span> worker <span class="hljs-keyword">in</span> threads:<br>        job = <span class="hljs-keyword">lambda</span>: worker.run(exploit_tree, target_tree, saver, env.save_file)<br>        t = threading.Thread(target=job)<br>        t.start()<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># Execute testing.</span><br>    <span class="hljs-comment"># Restore learned model from local file.</span><br>    util.print_message(OK, <span class="hljs-string">&#x27;Restore learned data.&#x27;</span>)<br>    saver.restore(SESS, env.save_file)<br>    <span class="hljs-keyword">for</span> worker <span class="hljs-keyword">in</span> threads:<br>        job = <span class="hljs-keyword">lambda</span>: worker.run(exploit_tree, target_tree)<br>        t = threading.Thread(target=job)<br>        t.start()<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="四-测试"><a href="#四-测试" class="headerlink" title="四. 测试"></a>四. 测试</h2><p>测试用例：<a target="_blank" rel="noopener" href="https://www.vulnhub.com/entry/empire-breakout,751/">https://www.vulnhub.com/entry/empire-breakout,751/</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="category-chain-item">学习笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">#渗透测试</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Deep Exploit 程序分析</div>
      <div>https://isolator-1.github.io/2024/06/06/学习笔记/DeepExploit/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Isolator</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>June 6, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/07/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/" title="自动化渗透测试环境">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">自动化渗透测试环境</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/04/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%8F%E8%AE%AE%E8%AF%AD%E6%B3%95%E9%80%86%E5%90%91/" title="协议语法逆向">
                        <span class="hidden-mobile">协议语法逆向</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        Views: 
        <span id="busuanzi_value_site_pv"></span>
        
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        Visitors: 
        <span id="busuanzi_value_site_uv"></span>
        
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
